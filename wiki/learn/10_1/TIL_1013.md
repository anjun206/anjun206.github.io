# 메모리 매핑 파일 (Memory Mapped Files)

메모리-매핑된 페이지 구현하는게 목적이다

메모리-매핑된 페이지는 파일-백드(file-backed) 매핑으로 익명(anonymous) 페이지와 다르다

페이지 폴트 발생 시, 물리 프레임 즉시 할당 후 파일에서 메모리로 내용 복사해야한다

페이지의 내용은 기존 파일의 데이터를 그대로 반영한다

메모리-매핑된 페이지가 언매핑되거나 스왑 아웃될 때는, 내용의 변경사항이 파일에 반영되어야 한다


## mmap과 munmap 시스템 콜

메모리-매핑 파일을 위해 `mmap`과 `munmap`을 구현해야 한다

VM 시스템은 `mmap` 영역의 페이지들을 지연로딩 해야 하고 `mmap`된 파일 자체를 사용해야 한다<br>
(스왑 공간 X 원본도 쓰는 것도 전부 `mmap`된 파일에서)

이를 위해 `vm/file.c`에 `do_mmap`하고 `do_munmap`을 구현해서 쓰라고 한다

### `mmap`

```c
void *mmap (void *addr, size_t length, int writable, int fd, off_t offset);
```

`fd`로 열린 파일의 `offset`부터 `length`까지 바이트를 `addr`에 매핑한다

파일 전체는 `addr`부터 쭉 매핑된다

매핑 페이지의 일부 바이트가 파일 끝을 넘어 나올때가 있는데 이들은 페이지가 폴트로 적재될 때 0으로 채워야하며, 디스크로 다시 기록될때 버려야 한다

쉽게 말해 파일 내용보다 페이지가 커서 남는 부분 처리하는 방법이다

성공 시 매핑된 가상 주소 반환하고 실패시 `NULL` 반환하면 된다

`mmap` 호출이 실패하는 경우는

- `fd`로 열린 파일의 **길이가 0바이트**
- `addr`이 **페이지 정렬** 안됨
- 매핑할 페이지 범위가 기존 매핑과 **겹침**
- `addr`이 0임
- `length`가 0임

일때 실패해야 한다

콘솔 입출력 fd는 당연히 매핑할 수 없다

메모리-매핑된 페이지도 익명 페이지와 마찬가지로 지연 할당되어야 한다. 페이지 객체를 만들기 위해 `vm_alloc_page_with_initializer` 또는 `vm_alloc_page`를 사용가능하다

___

### `munmap`

```c
void munmap (void *addr);
```

`addr`은 `mmap`성공한 가상 주소여야 한다

매핑 해제하면 된다

프로세스가 종료되면 암묵적으로 모든 매핑 언매핑해야한다

언매핑 할 때에 프로세스가 작성한 페이지들은 파일에 다시 기록되어야 하며, 작성되지 않은 페이지들은 기록되면 안 된다

그 후 해당 페이지들은 프로세스의 가상 페이지 목록에서 제거된다

파일을 닫거나 제거하더라도 파일의 매핑은 해제되지 않는다

한 번 생성된 매핑은 `munmap`이 호출되거나 프로세스가 종료될 때까지 유효하다

이를 위해 독립적 파일 참조가 필요하니 `file_reopen` 함수를 사용해야한다

<br>

## vm/vm.c의 초기화기 수정

`vm_file_init`하고 `vm_file_initializer`도 수정할 수 있다

```c
void vm_file_init (void);
```

파일-백드 페이지 서브시스템을 초기화해준다

대충 전역변수, 자료구조 등 초기화 해주는 듯하다

<br>

```c
bool file_backed_initializer (struct page *page, enum vm_type type, void *kva);
```

파일-백드 페이지를 초기화한다

`page->operations`에 파일-백드 페이지용 핸들러들을 설정한다

또한 페이지를 백업하는 파일 등, `page` 구조체의 필요한 정보를 갱신할 수 있다


<br>

```c
static void file_backed_destroy (struct page *page);
```

연결된 파일을 닫아 파일-백드 페이지를 파괴

건드려졌다면 이를 파일에 기록해놓아야 한다

`page` 구조체 자체는 호출자가 처리해야 한다