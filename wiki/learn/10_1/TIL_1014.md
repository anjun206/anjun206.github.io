# 스왑 인/아웃

메모리 스와핑 구현 필요하다

프레임 전부 쓰고 있을때 추가 메모리 요청시 안쓰는 프레임 스왑 아웃해서 자원 확보해주면 된다

운영체제 측에서 스와핑 수행한다
<br><br>

메모리 부족한 상태에서 메모리 할당 요청을 받을시 스왑 디스크로 축출할 페이지를 선택한다

이후 메모리 프레임의 상태를 디스크에 복사한다

만약 어떤 프로세스가 스왑 아웃된 페이지에 접긍하려 할 시 OS는 디스크에서 그 내용을 다시 메모리로 가져와 페이지를 복구한다
<br><br>

축출 대상은 익명 페이지거나 파일-백드 페이지이고 여기선 둘다 다뤄야 한다...

스와핑 연산은 명시적으로 호출되지 않고 모두 **함수 포인터**로 호출된다

`struct page_operations file_ops`같은 거 보면 안다

<br>

## 익명 페이지

`vm/anon.c`를 제대로 건들 시간이다

일단, `vm_anon_init`과 `anon_initalizer`를 수정해야한다

익명 페이지는 자체 백킹 스토어가 없기에

스왑 디스크 제공해준다

이를 활용해 구현하면 된다

```c
void vm_anon_init (void);
```
 
스왑 디스크 설정해줘야 한다

스왑 디스크의 **사용중과 비어있는 영역을 관리**할 자료구조도 필요하다

스왑 영역은 **PGSIZE(4096바이트)** 단위로 관리한다

<br>

```c
bool anon_initializer (struct page *page, enum vm_type type, void *kva);
```

익명 페이지 초기화기다

스와핑을 지원하기 위해 `anon_page`에 필요한 정보를 추가해야 한다

<br>

그리고나서는 `anon_swap_in`과 `anon_swap_out`을 구현해야한다

`anon_swap_out`을 먼저 구현하는 걸 추천한다

스왑아웃되어야 스왑인 가능하니 말이다

```c
static bool anon_swap_in (struct page *page, void *kva);
```

스왑 디스크에서 데이터를 읽어 메모리로 복사하여 익명 페이지를 스왑 인 시켜야 한다

데이터의 디스크 내 위치는 페이지가 스와프 아웃될 때 페이지 구조체에 저장되어 있어야 한다

스왑 테이블 갱신도 해줘야 한다

<br>

```c
static bool anon_swap_out (struct page *page);
```

메모리의 내용을 디스크로 복사하여 익명 페이지를 스왑 아웃하면 된다

먼저 스왑 테이블을 사용해 디스크에서 비어 있는 스왑 슬롯을 찾은 다음, 한 페이지 분량의 데이터를 그 슬롯에 쓴다

데이터의 위치는 페이지 구조체에 저장해야 한다

사용 가능한 스왑 슬롯이 더 없다면 커널을 패닉(panic)시키면 된다고 한다

<br>

## 파일 기반 페이지 (File-Mapped Page)

익명 페이지와 달리 어디서 왔는지 알 수 있다 (파일)

`mmap`된 파일을 백킹 스토리지로 사용하면 된다

파일 기반 페이지 퇴출할 때에 매핑된 파일로 내용을 다시 기록해야 한다

```c
static bool file_backed_swap_in (struct page *page, void *kva);
```

파일에서 내용 읽어와 `kva`에 페이지를 스왑 인 한다

파일 시스템과 동기화 해줘야 한다

<br>

```c
static bool file_backed_swap_out (struct page *page);
```

페이지 내용을 파일에 다시 기록해 스왑 아웃한다

페이지가 dirty인지 확인하는 것이 좋다고 한다

dirty가 아니면 수정할 필요 없으니

스왑 아웃 이후에 페이지의 dirty 비트를 해제해줘야 한다