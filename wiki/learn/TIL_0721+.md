# 2.1 대강 요약

단원의 소단원의 소단원을 요약해보았다...

## 1. 비트와 바이트의 세계 (2.1.1~2.1.3)
- 비트(bit): 정보의 최소 단위, 0 또는 1의 값을 가짐.

- 바이트(byte): 8개의 비트로 구성된 데이터의 기본 단위.

- 메모리 주소: 각 바이트마다 고유한 주소가 할당됨.

- 엔디안(endian): 여러 바이트로 이루어진 데이터(예: int, float 등)가 메모리에 저장되는 순서.

    - 리틀 엔디안: 가장 작은 바이트(최하위)가 앞에 옴(예: x86)

    - 빅 엔디안: 가장 큰 바이트(최상위)가 앞에 옴(네트워크 표준 등)

- 응용: 대부분의 고수준 언어에서는 이런 차이가 드러나지 않지만, 네트워크 통신이나 바이너리 데이터 해석 시 중요하게 작용함.

## 2. 문자열과 코드의 표현 (2.1.4~2.1.5)
- 문자열(string): 문자들의 배열 + 마지막에 널(null) 문자(\0)로 종료됨.

- ASCII 코드: 문자에 고유한 1바이트 값을 부여한 표준.

- 코드의 표현: 프로그램(함수 등)도 컴퓨터 내부에서는 바이트의 연속, 즉 비트 패턴의 나열로 저장됨.

- 호환성: 텍스트 데이터는 플랫폼에 따라 크게 다르지 않지만, 바이너리(실행 파일 등)는 머신과 OS에 따라 달라져 이식성이 떨어짐.

## 3. 불 대수와 비트 벡터 (2.1.6)
- 불 대수(Boolean Algebra): 0과 1로 논리 연산을 수행하는 수학적 체계.
(AND, OR, NOT, XOR 등)

- 비트 벡터(bit vector): 여러 비트(0과 1)로 이루어진 배열. 집합, 마스크 등 다양하게 활용됨.

- 비트 연산의 실용성: 집합 연산(합집합, 교집합, 여집합 등)이나 신호 마스킹 등에 직접적으로 사용됨.

## 4. C 언어의 비트/논리 연산자와 시프트 (2.1.7~2.1.9)
- 비트 연산자: &, |, ^, ~ 등으로, 각 비트별로 연산.

    - 마스킹(masking): 원하는 비트만 추출하거나 끄는 데 자주 사용

- 논리 연산자: &&, ||, !

    - 입력값이 0이 아니면 true(1), 0이면 false(0)로 간주

    - 단락 평가(short-circuit) 적용: 앞 조건만으로 결과가 정해지면 뒤는 아예 평가하지 않음

- 시프트 연산자: << (왼쪽 시프트), >> (오른쪽 시프트)

    - 오른쪽 시프트: 부호 있는 타입(signed)은 산술 시프트(부호 비트 유지), 부호 없는 타입(unsigned)은 논리 시프트(0 채움)

    - 자바(Java) 등 일부 언어는 명확하게 시프트 방식을 정의함

# 마무리

모든 정보는 0과 1의 패턴이며, 다양한 연산으로 조작됨