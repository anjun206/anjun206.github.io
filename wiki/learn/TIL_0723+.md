<br><br>
다시 돌아온 cs타임이다
<br><br><br>
creep score도 cs탄도 아닌
<br><br><br>
compunter science니 걱정 말도록
<br><br>
<br>
미리 스포하자면
<br><br>
숫자 얘기 나온다
<br><br>
(따봉하는 개구리 그림)
<br><br>
<br><br>

# 2.2 정수의 표시
비트를 통해 정수를 인코딩 해보겠다
<br><br>
비트에 몸을 맡겨라!
<br><br>
# 2.2.1 정수형 데이터 타입
대충<br>

C에선 정수형 데이터 타입이 비부호형, 부호형 말고도<br>
char, short, long도 있다는 내용
<br><br>
<br>
# 2.2.2 비부호형 인코딩
대충 <br>

`w`비트 부호없는 이진수는 0 ~ $2^w - 1$까지 표현가능하다는 내용
<br><br><br>

# 2.2.3 2의 보수 인코딩
그 보수 아니고 보수(補數)라는 뜻이다
<br>
<br>
2의 보수란?<br>
컴퓨터에서 일반적으로 음수 표현하는 방식이다<br>
모든 비트를 반전시키고 1을 더하면 된다<br>
1 -> 0<br>
0 -> 1 <br>
이런식으로 말이다
<br><br>
2의 보수가 있다는 건...<br>
<br><br>
1의 보수도 있다는 거다!<br><br><br>
1의 보수란?<br>
모든 비트를 반전시키는 걸 말한다<br><br>
얜 1 더하지도 않는다<br>
<br>
엥? 그럼 1의 보수가 더 쉬운데
<br><br>
왜 2의 보수를 쓰는거지?
<br><br>
<br>
그건...
<br><br>
<br>
1의 보수를 쓰면 0이 2개가 되기 때문이다
<br><br>
`00000000`도 0이고 이를 반전한<br>
`11111111`도 0이 되버린다...<br><br>
그리고 (부호) - (크기) 방식이란 것도 있는데<br>
<br>
맨앞 비트만 부호로 쓰고 나머진 절댓값 취급 하는거다<br><br>
얘도 0이 두개라 안쓴다
<br>
___
|   방식  | -18 (8비트 예시) | 0의 개수 | 특징/단점            |
| :---: | :----------: | :---: | :--------------- |
| 1의 보수 |   11101101   |   2개  | 0이 2개, 연산 불편     |
| 부호-크기 |   10010010   |   2개  | 0이 2개, 회로 복잡     |
| 2의 보수 |   11101110   |   1개  | 표준, 회로 단순, 0이 1개 |
___
<br>
그래서 보통 2의 보수 방식으로 인코-딩한다<br><br>
<br>

# 2.2.4 비부호형과 부호형 간의 전환
- **비트 배열(메모리 값)은 그대로**지만,<br>
**해석 방식**(signed/unsigned)에 따라 값이 달라짐.
<br><br>
- 예시:

    - 8비트 `11111111`

        - unsigned: **255**

        - signed: **-1** (2의 보수)

<br><br>

# 2.2.5 C에서 부호형과 비부호형의 비교

**부호형(signed)** 과 **비부호형(unsigned)** 변수끼리 연산하면,

자동으로 둘 다 비부호형(unsigned)으로 바뀐다

그렇기에 음수도 큰 양수로 취급되어 버리고 말이다...

예시)
```c
int a = -1;
unsigned int b = 0;
printf("%d\n", a > b);   // 1 (true) ← 둘 다 int로 비교
printf("%d\n", a > 0U);  // 0 (false) ← -1이 unsigned로 바뀌어 큰 수가 됨
```
<br><br><br>
> printf 서식 지정자 표
___
| 서식 지정자 |    의미   |       예시 값      |        출력 예시        |                설명               |
| :----: | :-----: | :-------------: | :-----------------: | :-----------------------------: |
|  `%d`  | 10진수 정수 |     123, -45    |       123, -45      |   **부호형(signed int) 10진수**로 출력  |
|  `%u`  | 10진수 정수 | 123, 4294967295 |   123, 4294967295   | **비부호형(unsigned int) 10진수**로 출력 |
|  `%x`  | 16진수 정수 |    255, 48879   |       ff, beef      |      **16진수(소문자)** 로 출력      |
|  `%X`  | 16진수 정수 |    255, 48879   |       FF, BEEF      |      **16진수(대문자)** 로 출력      |
|  `%f`  |    실수   |    3.14, -1.0   | 3.140000, -1.000000 |  **실수(double, float)** 로 출력  |
___
<br><br><br><br>


# 2.2.6 수의 비트 표시 확장 (확장법)
- **비부호형(unsigned):**

    - 0 앞에 0을 붙이면 값이 안 바뀜

        - 예: `[1100]` → `[00001100]`

- **부호형(signed, 2의 보수):**

    - **부호 비트(MSB)** 를 복사해서 앞에 붙임(부호 확장, sign extension)

        - 예: `[1100]` → `[11111100]` (음수 유지)

- **길이 확장+부호/비부호 변환 동시**

    - **int y = (signed char) x;** 처럼 변환시 해석에 주의


<br><br><br>

# 2.2.7 수의 절삭
ㅈㄴ 간단하다

더 작은 비트수로 자름(오른쪽만 남김)

그리고 남은 곳만 해석방식에 따라 읽으면 끝

- 예시:

    - 16비트 `0xFFAB`를 8비트로 자르면

        - `[11111010 10111011]` → `[10111011]`

        - unsigned: 187

        - signed: -69

<br><br><br>

# 2.2.8 Signed와 Unsigned의 조언
signed ↔ unsigned 함부로 바꾸다가 값이 지랄 날 수 있다
<br><br>
비부호형은 ㄹㅇ 죽어도 음수 안나온다 할때에만 사용하고
<br><br>
에지간해선 부호형을 쓸 것