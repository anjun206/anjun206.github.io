오늘은 Pintos 2일차다

이번에 나온 할나 실크송 하려면 효율적으로 Pintos 하는게 중요하다

그래서 가이드북인 GitBook 읽었다

프로젝트 1이 이번주차 과제이기에

- 프로젝트 1: 스레드

    - 소개

    - 알람 클락

    - 우선 스케줄링

    - 향상된 스케줄러

    - FAQ

만 읽으면 된다

핵심과 중요 개념 등 유용한 정보가 꽉 차 있어 읽을 맛 난다

...

<br>

# 프로젝트 1: 스레드

## 소개

여기 부분이 가장 긴 거 같다

### 배경 (Background)

초기 스레드 시스템 코드 읽어보라고 한다

기본으로 주어진 코드 설명 나오는데 이건 각자 읽어보자
<br><br>

Pintos의 **스레드는 약 4kB보다 조금 작은 고정 크기의 실행 스택**이기에

큰 데이터 구조를 비정적 지역 변수 로 선언하는 등의 일을 벌인다면 커널 패닉등이 발생하니

유의해야 한다 스택 오버플로 감지는 한다만... 완벽하지 않다고 한다

큰 데이터 쓸거면 페이지 할당자, 블록 할당자 같은 [메모리 할당](TIL_0905+.md)으로 해결해라

___

### 소스파일

간단하게 c파일들 설명들이다

뭐 건드리고 건드리지 말아야하고 뭐하는 애들인지 나오는데

필요할 때만 찾아보면 되니 가볍게만 읽자

___

### 동기화 (Synchronization)

이번 주차에서 동기화는 무척 중요하다 (사실 늘 중요할 거 같긴 하다)

Pintos에서는 여러 원시적 동기화 방법(인터럽트 비활성화, 세마포어 등등)이 있으니

뭘 써야 할지 고민이라면 [동기화](TIL_0904+.md) 보자
<br><br>

인터럽트 비활성화 쓰기 가장 좋을 때에는

**커널 스레드와 인터럽트 핸들러 사이에서 공유하는 데이터 조정**이란다

공유 자료구조 같은 건 원래라면 **락**으로 못건들게 하면 되지만

인터럽트 핸들러는 그런 거 모른다 그렇기에 아예 접근 자체도 못하게 꺼버려야 한다
<br><br>

인터럽트 비활성화는 좀 필요하지만 남용 금지고 조금만 써야 한다

중요 이벤트 꺼버릴 수도 있고 인터럽트 끄면 인터럽트 처리 지연(latency) 이 증가하여 과도할 경우 시스템이 버벅거린다나 뭐라나

___

### 개발 제안 (Development Suggestions)

각자 하다가 마지막에 합치지 말고

중간중간 계속해서 서로 점검하란다

<br><br>


## 알람 시계 (Alarm Clock)

`devices/timer.c`에 정의된 `timer_sleep()`을 재구현하세요

기본으로 구현된 동작은 **바쁜 대기(busy waiting)** 라는 졸라 구린 방식이라

이를 피하는 방식으로 재구현해야 한다

*바쁜 대기란?*<br>
**조건이 만족될 때까지** 구질구질하게 **계속 CPU 붙잡아 확인하는 방식**으로<br>
딱 들으면 알겠듯이 자원 낭비 야무지게 한다

그러니 이거 쓰지 않기 위해 새로 알람 시계를 구현하라는데

```c
void timer_sleep (int64_t ticks);
```
> 호출한 스레드의 실행을, 적어도 `x` 타이머 틱만큼 시간이 지날 때까지 중단<br>
다른 일(READY 스레드)이 돌아가고 있다면 정확히 `x` 틱 후일 필요는 없고<br>
정해진 시간만큼 대기했다면 레디 큐에 넣어주면 된다다

기본적으로 pintos는 100틱이 1초다

`TIMER_FREQ`개의 틱이 1초에 있는 틱으로

`TIMER_FREQ`는 `devices/timer.h`에 정의된 매크로로 수정가능하다

그치만 수정은 권장하지는 않는다고 한다

\+ 밀리초·마이크로초·나노초 단위로 잠들게 하는 `timer_msleep()`, `timer_usleep()`, `timer_nsleep()` 함수도 따로 제공된다<br>
이들은 필요하면 알아서 `timer_sleep()` 호출하니 수정할 필요없다

\++ 그리고 사실 알람 시계 구현은 필수는 아니지만 프로젝트 4에서 유용할 수 있다고 한다

<br><br>

[알람 시계 재구현](TIL_0905++.md)