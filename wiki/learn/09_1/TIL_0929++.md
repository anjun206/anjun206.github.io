# 구조체

프로젝트 3에서 쓰이는 구조체와 인자들 간략하게 짚고 넘어가보자

## 페이지 구조체

가상 메모리의 메타데이터를 담당하고 있다

va의 타입(anon/file), writable 여부, 폴트났을때 채울 정보(init/aux)가 있다

```c
/* "page"의 표현(구조체).
 * 이 구조체는 일종의 '부모 클래스'이며,
 * 자식 클래스는 uninit_page, file_page, anon_page, (프로젝트4의) page_cache 입니다.
 * 이 구조체의 미리 정의된 멤버는 제거하거나 수정하지 마십시오. */
struct page {
	const struct page_operations *operations;
	void *va;              /* 사용자 공간 기준 주소 */
	struct frame *frame;   /* 프레임에 대한 역참조 포인터 */

  	struct hash_elem spt_elem;  // 보조 페이지 테이블(SPT)용 해시 요소
    /* 👇 위에 두 놈이 새로 추가한거다 👆 */
	bool writable;	// 쓰기 가능 매핑 여부

	/* (필요 시) 여러분의 구현을 여기에 추가합니다. */

	/* 타입별 데이터는 유니언에 묶여 있습니다.
	 * 각 함수는 현재 활성화된 유니언 멤버를 자동으로 판별합니다. */
	union {
		struct uninit_page uninit;
		struct anon_page anon;
		struct file_page file;
#ifdef EFILESYS
		struct page_cache page_cache;
#endif
	};
};
```
> 적혀있는 주석 번역본하고 약간의 설명이다

___

<br>

### `const struct page_operations *operations;`

현재 페이지의 정보 가리킨다

C에서는 클래스가 없기에 이를 대체해주는 역할한다

`UNINIT`, `ANON`, `FILE` 타입별에 대한 동작을 함수 포인터 테이블로 추상화 해놓았다

보통 `UNINT` 상태에서 -> `ANON` 또는 `FILE`로 교체한다

___

### `void *va;`

페이지의 사용자 가상 주소다

`pml4_set_page`할때 인자로 쓰이고

SPT 키로도 사용가능하다

___

### `struct frame *frame;`

이 페이지가 현재 점유 중인 물리 프레임(없으면 NULL)

나중에 추출(evict) 구현 시 해당 프레임의 주인 page로 되돌아가 swap_out 수행

___

### `struct hash_elem spt_elem;`

해시 테이블 쓰기 위한 노드다

___

### `bool writable;`

PTE 권한에서의 쓰기 가능 여부다

___

### `union { uninit, anon, file, page_cache }`

타입별 추가상태 저장소다

uninit, anon, file 등 ops상태 나타낸다

#### `struct uninit_page uninit`

아직 안 채운 페이지로 초기화 상태다

#### `struct anon_page anon`

파일이 아닌 익명 메모리다

#### `struct file_page file`

파일 기반 페이지다

<br>

## 프레임 구조체

물리쪽 실체로 이 물리 프레임의 가상주소랑 이 프레임 무슨 page가 쓰는지 연결이 있다

```c
struct frame {
	void *kva;
	struct page *page;
};
```

___

<br>

### `void *kva;`

물리 프레임이 매핑된 커널 가상 구조다

___

### `struct page *page;`

이 프레임을 소유하는 `page`

프레임에서 주인 역참조해서 swap_out/destroy 등 나중에 해야 한다

<br>

## `struct page_operations`

vtable(가상 메서드 테이블)이다

타입별로  swap_in / swap_out / destroy를 어떻게 할지 모아놓은 포인터 세트다

```c
/* 페이지 연산을 위한 함수 테이블.
 * C에서 "인터페이스"를 구현하는 한 가지 방식이다.
 * 구조체의 멤버로 "메서드" 테이블(함수 포인터 집합)을 넣어 두고,
 * 필요할 때 그 메서드를 호출한다. */
struct page_operations {
	bool (*swap_in) (struct page *, void *);
	bool (*swap_out) (struct page *);
	void (*destroy) (struct page *);
	enum vm_type type;
};
```

### `bool (*swap_in)(struct page *, void *kva);`

이 페이지 내용을 **프레임(kva)** 으로 채워 넣는” 동작

### `bool (*swap_out)(struct page *);`

이 페이지를 **프레임에서 내보내는**(evict) 동작

### `void (*destroy)(struct page *);`

프로세스 종료/페이지 제거 시 **타입별 정리**

셋 모두 타입별로 동작이 다르다

### `enum vm_type type;`

이 vtable이 표현하는 **논리 타입**(UNINIT/ANON/FILE…)을 나타낸다