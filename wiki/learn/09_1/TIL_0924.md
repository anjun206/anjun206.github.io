# 프로젝트 3 소개

[이전 1](TIL_0920.md)

[이전 2](TIL_0923+.md)

## 스왑 테이블 관리

**스왑 테이블**은 **스왑 슬롯의 사용/여유**를 추적한다

스왑으로 내보낼 떄 사용할 **미사용 스왑 슬롯 선택**<br>
페이지가 프레임으로 돌아오거나 해당 프로세스 종료될 때 **스왑 슬롯 해제**<br>
를 지원해야 한다
<br><br>

`vm/build` 디렉터리에서 스왑 파티션이 포함된 디스크를 이 명령어로 만들 수 있다

[스왑 파티션?](TIL_0924+.md#스왑-파티션)

```cmd
pintos-mkdisk swap.dsk --swap-size=n
```

이후 `swap.dsk`는 pintos 실행 시 **추가 디스크로 자동 부착**

아니면 **임시 nMB 스왑 디스크** 사용할 수 있는데 `--swap-size=n`을 pintos 실행 인자에 주면 된다고 한다

그래서 이게 뭐하는 거야 하면 페이지 스왑 할때 사용할 임시 메모리 저장소 만드는 거라고 보면 된다

스왑 슬롯은 지연 할당(lazy allocation)해야 한다

미리 하지 말고 진짜 축출이 필요할 때만 할당 하라는 뜻이다

이후, 페이지 내용이 프레임으로 다시 읽혀오면 스왑 슬롯 해제하면 된다

<br>

## 메모리 매핑 파일 관리(Managing Memory Mapped Files)

파일 시스템은 일반적으로 `read`/`write` 시스템 콜로 접근한다

그치만 보조 인터페이스로는 파일을 `mmap` 시스템 콜을 통해 가상 페이지에 매핑 가능하다

`read`/`write`로 접근할 경우 “파일 → 커널 버퍼 → 사용자 버퍼”로 복사 2번을 해야 하지만

`mmap`로 접근할 경우 파일을 **가상 페이지**간주하고 **페이지 폴트가 I/O를 트리거**<br>
그 이후는 포인터로 바로 접근한다

접근해서 쓰고 난 뒤에서는 `munmap`으로 해제 해줘야 한다
<br><br>

구현관점에서 중요한건

**메모리 매핑된 파일이 사용하는 메모리를 추적**할 수 있어야 한다는 것이다

<br>

## 요약

- **SPT/프레임 테이블/스왑 테이블**을 설계·구현해야 한다

- **페이지 폴트 핸들러**(`vm_try_handle_fault`)가 SPT 기반으로 **lazy 하게** 페이지를 적재하고, 필요 시 **eviction + swap**을 수행하도록 한다

- 사용자 페이지 프레임은 반드시 **user pool**에서 `PAL_USER`로 할당한다

- **accessed/dirty 비트**와 **에일리어스** 문제를 올바르게 처리해야 한다

- `mmap`/`munmap`으로 **파일 매핑**을 지원하며, **중첩/겹침 방지**와 **페이지 폴트 처리**가 가능해야 한다