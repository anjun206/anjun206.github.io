지금 할 건 프로젝트 2 들어와서 가장 먼저 보이는거다

그건 바로...

인자 전달!<br>
q(≧▽≦q)<br>
꺄아아~~ (비명 지르는 중)

<br>

참고로 현재 독서왕 김독서 상태다

# Argument Passing

인자 전달이라는 뜻

일단, `process_exec()`에서 사용자 프로그램의 인자 설정하기라는데

`process_exec()`가 뭔지부터 보자

유닉스의 `execve()`와 같은 역할을 하는 함수로

실행 중 프로세스의 껍데기(스레드/PID)는 냅두고<br>
그 안의 사용자 프로그램을 새로 갈아 끼우는 역할을 한다

`process_execute`와 비슷하게 생겼지만 얘는 프로세스 새로 만드는 거고<br>
`process_exec`는 기존 프로세스에 프로그램 이미지(주소공간)만 갈아끼워 쓰는 거다

<br>

## x86-64 호출 규약 (Calling Convention)

x86-64의 호출 규약의 핵심 나온다

호출 규약이 뭐냐?

함수 호출을 위한 약속이다 뭐 전달하고 어떻게 반환값 받는지 등등
<br><br>

- 사용자 수준 애플리케이션은 정수 인자 전달에 레지스터 순서 사용<br>
`%rdi` 1번째 인자<br>
`%rsi` 2번째 인자<br>
`%rdx` 3번째 인자<br>
`%rcx` 4번째 인자<br>
`%r8` &#160;&#160;5번째 인자<br>
`%r9` &#160;&#160;6번째 인자

- 호출자는 자신의 다음 명령의 주소를 스택에 푸쉬하고<br>
피호출자의 첫 명령으로 점프 `CALL`로 이 두가지 모두 수행

- 피호출자가 실행된다

- 피호출자가 반환값이 있다면 이를 레지스터 `RAX`에 저장한다

- 피호출자는 스택에서 반환 주소 팝해 해당 위치로 점프한다<br>
**이것이 `RET` 명령어**

> 실제 동작시에는 추가 동작이 들어가기에 `RET`이 더 안전하고 빠르게 복귀하게 해준다

<br>

## 프로그램 시작 세부사항 (Program Startup Details)

Pintos의 사용자 프로그램용 C 라이브러리는 `lib/user/entr.c`의 `_start()`를 시작점으로 삼는다<br>(프로그램의 엔트리 포인트)

> `main()` 호출하고 반환되면 `exit()` 호출한다
```c
void
_start (int argc, char *argv[]) {
    exit (main (argc, argv));
}
```

<br>

커널은 시작전 초기 함수의 인자들을 **레지스터에 적재**해야 한다

인자 전달 방식은 [호출 규약](#x86-64-호출-규약-calling-convention)과 동일
<br><br>

### 예시

`/bin/ls -l foo bar`라는 명령의 인자 처리 시

1. 명령을 단어(토큰)로 분할: `/bin/ls`, `-l`, `foo`, `bar`

2. 이 문자열들을 스택 상단에 배치<br>
어차피 포인터로 참조해 **배치 순서는 상관 ✕**

3. 각 문자열의 주소 뒤에 널 포인터 센티널 `\0` 을 더해 끝을 표시하고,<br>
**오른쪽에서 왼쪽 순서**로 스택에 푸시
<br><br>
이것들이 `argv`의 요소
    - 널 포인터 센티널은 `argv[argc]`가 널포인터가 되도록 보장 <br>(C표준 요구 사항, 문자열 마지막 규칙)
    - 이 순서는 `argv[0]`가 **가장 낮은** 가상주소에 오도록 한다
    - 워드 정렬(정렬된 접근, word-aligned)이 비정렬 접근보다 빠르므로, <br>
    첫 푸시 전에 스택 포인터를 **8의 배수로 내림(round down)** 처리하면 성능 향상

> 가장 낮은 가상 주소는 스택의 꼭대기다

4. `%rsi`는 `argv`(= `argv[0]`의 주소)를 가리키게 하고, `%rdi`에는 `argc`를 설정

5. 마지막으로, 가짜 “반환 주소”를 하나 푸시<br>
실제 반환하지 않지만, 호출 규약 맞추며, <br>
만약에 `RET`에 의해 복귀해도 반환주소가 없어 페이지 폴트<br>
-> 깨끗이 종료 처리<br>
스택 프레임 모양도 맞추었기에 다루기도 편하다

<br>

## 인자 전달 구현

현재 process_exec()은 새 프로세스에 인자를 전달하지 않으니 이를 구현하면 된다

단순 파일 이름 받는 대신 공백 기준 **단어로 분해**하며

첫 단어는 프로그램 이름, 두 번째 단어는 첫 인자 등등으로 처리

> 예) `process_exec("grep foo bar")`는 `grep`을 실행하며 인자로 `foo`와 `bar`를 전달

<br>

인자 문자열 파싱 방식은 자유<br>
`include/lib/string.h`에 프로토타입 존재<br>
`lib/string.c`에 주석이 풍부하게 구현된 `strtok_r()`도 참고 ㄱㄴ

부족하다면 터미널에서 `man strtok_r`로 매뉴얼 페이지를 확인