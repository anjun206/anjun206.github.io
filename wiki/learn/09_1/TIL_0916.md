현재 코드 짜다가 어지러워 흐름 한번 정리하려 한다

# fork

`fork`로 복제한다

## 흐름

### 자식 상태 구조체 생성

- 자식의 tid

- 종료 코드

- 종료 여부

- wait 여부

- 자식 종료 wait 세마포어

- exec/fork후 자식 로드 확인 세마포어

- childredn 리스트로 자식 노드 관리

<br>

___

<br>

### cpu 레지스터 저장

`thread_create(name, PRI_DEFAULT, __do_fork, aux)`

부모에서 현재 레지스터 값을 가지고 사본을 만들어<br>
새 스레드에 전달

<br>

___

<br>

### 자식 초기화

`__do_fork` 기점으로 자식 스레드 실행

레지스터 받은거 적용해 부모와 동일한 상태 CPU

이후 `my_status`를 자기자신에 해당하는 `child_status`를 가리키게 한다

그 뒤 `process_init()`으로 초기화

<br>

___

<br>

### 주소 공간 복제

자식 프로세스에서 새 페이지 디렉토리(PML4) 생성해<br>
부모 가상메모리 주소 공간 복제

현재는 부모 페이지 테이블의 각 유저 페이지를 새 페이지에 할당하고<br>
내용을 memcpy로 복사하는 방식

<br>

___

<br>

### 파일 디스크립터 복사

부모가 `fd_table`이 있으면 자식도 `fd_table`접근

이후, `file_duplicate`로 복사해 별도 객체 생성

<br>

___

<br>

### 자식 리턴 값 설정

자식은 0을 `fork()`의 반환값으로 사용해야 한다

이를 위해 복제된 레지스터의 RAX값은 0으로 설정

<br>

___

<br>

### 동기화 및 부모 복귀

메모리 복제와 리소스 초기화 완료시

자식은 부모에게 성공/실패 여부를 알려줘야한다

세마포어로 이를 확인한다

<br><br>

# exec

현재 프로세스를 새로운 실행파일로 덮어씌워 해당 프로그램을 실행한다
    
그리고 이를 새 프로세스 만들고  그 프로세스로 하여금 현재 프로세스 대체하게 하는 방식으로 구현했다

그치만 실패했다

내일 다시 해보이겠다