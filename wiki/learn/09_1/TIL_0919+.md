# 해시 테이블

이번 프로젝트 2하며

리스트를 자주 사용했는데

아무래도 선형탐색이다보니 좀 느린게 불만이었다

그리고 Pintos에서는 해시테이블이 존재한다...

없어도 괜찮지만 사용하면 훨씬 좋기에 어떻게 쓰는지 알아보자
<br><br>

## 준비

일단 기본적으로 사용할 구조체에 

`struct hash_elem`을 넣어줘야 한다

`struct list_elem` 넣어주듯이

```c
struct foo {
  KeyType key;         // 키(예: void* upage, int fd, char* name 등)
  /* ... 값 필드 ... */
  struct hash_elem he; // 필수
};
```

<br>

그리고 콜백 함수도 2개 정도 만들어놔야 준비 끝이다

```c
/* 해시 함수 */
static uint64_t foo_hash(const struct hash_elem *e, void *aux) {
  const struct foo *f = hash_entry(e, struct foo, he);
  return hash_bytes(&f->key, sizeof f->key);   // 포인터/정수면 이렇게 OK
}
```

```C
/* 정렬(less) 함수: 키만 비교 */
static bool foo_less(const struct hash_elem *a,
                     const struct hash_elem *b, void *aux) {
  const struct foo *fa = hash_entry(a, struct foo, he);
  const struct foo *fb = hash_entry(b, struct foo, he);
  return fa->key < fb->key;
}
```

## 생성/삽입/검색/삭제/파기

```C
/* 테이블 생성 */
struct hash ht;
ASSERT(hash_init(&ht, foo_hash, foo_less, NULL));  // aux 필요없으면 NULL

/* 삽입 */
struct foo *x = malloc(sizeof *x);
x->key = K;
/* ... 값 채우기 ... */
struct hash_elem *dup = hash_insert(&ht, &x->he); // 이미 있으면 그 원소 포인터 반환
ASSERT(dup == NULL);                              // 보통 중복 금지면 이렇게 체크

/* 검색: '키만 채운 가짜 엔트리'로 조회 */
struct foo key_only = {.key = K};
struct hash_elem *e = hash_find(&ht, &key_only.he);
struct foo *found = e ? hash_entry(e, struct foo, he) : NULL;

/* 삭제 */
if (found) {
  hash_delete(&ht, &found->he);   // 테이블에서 제거만
  free(found);                    // 실제 free는 사용자 몫
}

/* 전체 파기(+엔트리 free까지) */
static void foo_free(struct hash_elem *e, void *aux) {
  free(hash_entry(e, struct foo, he));
}
hash_destroy(&ht, foo_free);      // hash_clear(&ht, foo_free)도 동일 패턴
```