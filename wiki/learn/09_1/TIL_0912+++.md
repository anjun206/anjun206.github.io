PASS 하나라도 보는게 목표이기에 최소의 구현만으로 동작하는 거 확인하려 한다

그래서 흐름 정리하려 하는데 할 거 더럽게 많다;;

＿φ(￣ー￣ )<br>
(억지로 공부 중)

<br>

# 최소 가동 조건 (예상)

1. 커맨드 파싱 -> 자식 생성 & 대기

    `init.c: run_task()`에서 파싱후 자식 만들어

    `process_wait(child_tid)`로 대기

<br>

2. 자식 스레드에서 `process_exec`

    여기서 ELF 로드, 사용자 스택 빌드, 레지스터 세팅, `do_iret()`로 유저모드 진입

    전처리 처리

    이후 `_start → main → exit()`가 사용자 코드에서 실행

<br>

3. 사용자 코드가 `exit()`/`write()` 호출

    `lib/user/syscall.c` 래퍼가 `syscall`(RAX=번호, RDI/…=인자) 실행

<br>

4. 커널 `syscall_entry` → `syscall_handler()`

    디스패처에서 

- `SYS_EXIT`: `exit_status` 저장 → `thread_exit()` 흐름으로 `process_exit()` **호출**

- `SYS_WRITE(fd==1)`: `putbuf()`로 콘솔 출력, `RAX=size`

<br>

5. `process_exit()`에서 자원정리 + "exit(msg)" + `sema_up`

    자식이 종료코드 기록 & 세마 업 -> 부모가 깨어나 `process_wait()` 반환

<br>

6. 부모가 `process_wait()`가 정상 반환 -> run_task 마무리

    테스트 드라이버가 **`Execution of '…' complete.`** 까지 찍고, `-q`면 전원 오프

<br>

흐름 재정리 완료 했으니

따라가며 구현해보겠다

