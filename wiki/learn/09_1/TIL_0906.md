# 우선 순위 스케줄링 구현

오늘은 우선순위 스케줄링 할거다

일단 구조체부터 만져야 한다
<br><br>

## 구조체 만지기

우선순위 할거니까

```c
int base_priority;
int priority;
```

이 두 개를 스레드 구조체에 넣어줬다

`base_priority`는 걍 초기 배정값

`priority`가 현재 상태라 보면된다

그리고 추가로 [lock](TIL_0904+.md#락-locks)관련도 넣어줘야 한다

우선순위 이거 챙기는 이유가 lock 때문이니까

```c
struct lock * waiting_lock;
struct list locks;
```

락 구조체에서 기다리는 락 떼오고

리스트로 locks만들어줬다

리스트는 걍 냅두면 되고

`struct lock`은 지금 만들어주면 된다

```c
struct lock
{
	struct thread *holder;
	struct semaphore semaphore;
	struct list_elem elem; // holder->locks에 연결용
};
```

lock관련해서 필요한 애들만 담았다<br>
현재 lock 잡고 있는 스레드<br>
lock을 담당하는 [세마포어](TIL_0904+.md#세마포어-semaphores)<br>
그리고 스레드의 락 리스트 연결을 위한 노드까지

이거 다하니 벌써 오후 3시다

구조체만 했는데 시간 ㄹㅈㄷ
<br><br>

## synch.c

그 다음엔 `synch.c`에 존재하는 함수들 손봐야 한다

`sema_down()`, `sema_up()`

`lock_acquire()`, `lock_release()`

`cond_wait()`, `cond_signal()`, `cond_broadcast()`

이 이와 관련 있는 이들이다...

___

### sema

세마포어와 연관 있는, 즉, 사실살 락하는 거라 보면 된다

`sema_down` 할 때에 waiter 리스트에 뒤 쪽에 그냥 붙이는데

이를 정렬 삽입으로 수정해줬다

별 거 없고 `list_push_back`을 `list_insert_ordered`로 바꿔준 뒤<br>
`prio_greater`라는 비교 함수 하나 추가 하고 `sema_down`은 마무리

`sema_up`도 손봐줘야 한다

중간에 기부 일어나거나 하면 순서 바뀔 수 있으니

언블록 전에 정렬도 한번 하고 언블록하고 현재 실행중 스레드하고 우선순위 비교도 하고<br>
다 해줘야 한다

그렇다, 사실 `sema_down`에 삽입정렬도 딱히 필요없다

속도 좀 높아진다는 것 정도 말고 말이다...

`down`만 하면 정렬 필요 없는 줄 알았는데 이럴거면 `up` 먼저 손볼걸.. <br>
하며 아쉽지만 좋은게 좋은거라 넘어가자



## thread.c

`thread.c` 손볼때에 관련 있는 함수들 

`thread_unblock()`, `thread_set_priority()`, `thread_get_priority()`