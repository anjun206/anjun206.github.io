# 우선 순위 스케줄링 구현

오늘은 우선순위 스케줄링 할거다

일단 구조체부터 만져야 한다
<br><br>

## 구조체 만지기

우선순위 할거니까

```c
int base_priority;
int priority;
```

이 두 개를 스레드 구조체에 넣어줬다

`base_priority`는 걍 초기 배정값

`priority`가 현재 상태라 보면된다

그리고 추가로 [lock](TIL_0904+.md#락-locks)관련도 넣어줘야 한다

우선순위 이거 챙기는 이유가 lock 때문이니까

```c
struct lock * waiting_lock;
struct list locks;
```

락 구조체에서 기다리는 락 떼오고

리스트로 locks만들어줬다

리스트는 걍 냅두면 되고

`struct lock`은 지금 만들어주면 된다

```c
struct lock
{
	struct thread *holder;
	struct semaphore semaphore;
	struct list_elem elem; // holder->locks에 연결용
};
```

lock관련해서 필요한 애들만 담았다<br>
현재 lock 잡고 있는 스레드<br>
lock을 담당하는 [세마포어](TIL_0904+.md#세마포어-semaphores)<br>
그리고 스레드의 락 리스트 연결을 위한 노드까지

이거 다하니 벌써 오후 3시다

구조체만 했는데 시간 ㄹㅈㄷ
<br><br>

## synch.c

그 다음엔 `synch.c`에 존재하는 함수들 손봐야 한다

`sema_down()`, `sema_up()`

`lock_acquire()`, `lock_release()`

`cond_wait()`, `cond_signal()`, `cond_broadcast()`

이 이와 관련 있는 이들이다...

___

### sema

세마포어와 연관 있는, 즉, 사실살 락하는 거라 보면 된다

`sema_down` 할 때에 waiter 리스트에 뒤 쪽에 그냥 붙이는데

이를 정렬 삽입으로 수정해줬다

별 거 없고 `list_push_back`을 `list_insert_ordered`로 바꿔준 뒤<br>
`prio_greater`라는 비교 함수 하나 추가 하고 `sema_down`은 마무리

`sema_up`도 손봐줘야 한다

중간에 기부 일어나거나 하면 순서 바뀔 수 있으니

언블록 전에 정렬도 한번 하고 언블록하고 현재 실행중 스레드하고 우선순위 비교도 하고<br>
다 해줘야 한다

그렇다, 사실 `sema_down`에 삽입정렬도 딱히 필요없다

속도 좀 높아진다는 것 정도 말고 말이다...

`down`만 하면 정렬 필요 없는 줄 알았는데 이럴거면 `up` 먼저 손볼걸.. <br>
하며 아쉽지만 좋은게 좋은거라 넘어가자

왜냐하면 이보다 중요한게 있으니
<br><br>

기존 `sema_up`은 단순히 waiter 리스트에서 뽑아 언블록하고 세마포어 값 올리는게 끝이었다

이를 수정해서 뽑은 뒤 현재 일어난 스레드랑 실행 중 스레드 우선순위 비교해

바로 기부 받을지 말지 등 정해줘야 한다

일단 현재랑 깨어난 거 구분 위해 선언해준다
```c
struct thread * cur   = thread_current();
struct thread * woken = NULL;
```
이렇게 선언해 준 뒤

원래 함수의

```c
if (!list_empty (&sema->waiters))
	thread_unblock (list_entry (list_pop_front (&sema->waiters),
				struct thread, elem));
```

이걸 살짝 수정해준다

```c
if (!list_empty (&sema->waiters)) {
	list_sort(&sema->waiters, prio_greater, NULL);
	struct list_elem *e = list_pop_front(&sema->waiters);    // 최고 우선순위
	woken = list_entry(e, struct thread, elem);
	thread_unblock(woken);
}
```

바로 언블록 하는대신 중간에 대기 리스트 바뀌었을 것 까지 고려해

sort 한번 해준다

그리고 pop 해준다 (sort 했으니 맨 앞의 스레드의 우선순위가 대기 중 최고 우선순위)

이렇게 깨어난 애를 woken 에 지정해주고 언블록한다
<br><br>

사실 여기까지도 전야제였다

이제 현재 깨어난 애랑 원래 실행중인 스레드의 우선순위를 비교해줘야 한다

```c
bool preempt = (woken && woken->priority > cur->priority);

if (intr_context()) {
	if (preempt) intr_yield_on_return();
	intr_set_level(old_level);
} else {
	intr_set_level (old_level);
	if (preempt) thread_yield();
}
```

선점 관련해서 플래그 하나 만들어준다

woken이 존재하며 그 우선순위가 현재 실행중 보다 놓은지 확인

그리고 저 아래 `intr_context`는 안넣으면 낭패 볼 수 있다
<br><br>

**인터럽트 핸들러 내부**에서 실행된지 확인하는 건데

인터럽트 핸들러 내부일 경우에는 `thread_yield()`가 안되어 양보가 안된다;;

- **인터럽트 핸들러 안에서** 안되는 것들 목록

	- **블록 금지**<br>
	`thread_block()`, `sema_down()` 같이 잠들 수 있는 함수 호출 금지

	- **즉시 스케줄 전환 금지**<br>
	`thread_yield()`로 곧장 컨텍스트 스위치 X

	- **락 획득 주의**<br>
	블록될 수 있는 락/세마 획득 시도 금지

이럴 경우 **핸들러 복귀 직후 양보**하라고 `intr_yield_on_return()`을 써주면 해결! [emoji](emoji:marie_smile)

<br><br>

## thread.c

`thread.c` 손볼때에 관련 있는 함수들 

`thread_unblock()`, `thread_set_priority()`, `thread_get_priority()`