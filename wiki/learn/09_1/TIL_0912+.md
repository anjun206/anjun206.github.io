GitBOOK이다

프로젝트 2 기본적으로 테스트 돌리려면 다 읽어봐야 하기에

정리 한다

<br>

# 유저 메모리 (User Memory)

시스템 콜 구현하려면 사용자 가상 주소 공간의 데이터 읽고 쓰기가 필요하다

인자 가져오기만 할땐 그리 필요하지 않지만...

시스템 콜의 인자로 전달된 포인터가 가리키는 데이터를 읽거나 쓸 때는

반드시 필요하다 (프록시 기능)
<br><br>

잘못된 포인터, 커널 메모리 가리키는 포인터, 부분만 겹치는 블록을 넘길 수 있기엔

이러한 경우 **해당 사용자 프로세스 종료**해 처리해야 한다

<br>

# 시스템 콜 (System Calls)

`userprog/syscallc`에 시스템 콜 핸들러 구현해야한다

기본 스켈레톤 구현은 그냥 프로세스 종료하지 시스템 콜 처리 안한다

시스템 콜 번호 가져와 인자를 읽어 동작 수행하도록 바꿔야 한다
<br><br>

## 시스템 콜 상세

운영체제가 사용자 프로그램으로 부터 **제외 되찾는** 방식을 배웠고

CPU 외부의 요인으로 발생하기에 **외부 인터럽트**라고 한다
<br><br>

운영체제는 **소프트웨어 예외**(프로그램 코드에서 발생하는 사건)도 처리해야 한다

페이지 폴트, 0으로 나누기 등이 그 오류다

예외는 또한 시스템 콜이기도 하다
<br><br>

`syscall` 명령은 시스템 콜을 호출하는 가장 일반적인 수단이다

Pintos에서도 이를 쓴다

유의할 점은 `syscall`을 실행하기 **직전** 일반적인 규약대로

레지스터에 시스템 콜 번화와 인자들을 설정해야 한다는건데 두 가지 예외가 있다

- `%rax`에는 **시스템 콜 번호**를 넣는다

- **네 번째 인자**는 `%rcx`가 아니라 **`%r10`** 에 담는다

따라서 `syscall_handler()`가 제어를 넘겨받을 때,

시스템 콜 번호는 **`rax`** 에 있고

인자들은 `%rdi`, `%rsi`, `%rdx`, `%r10`, `%r8`, `%r9` 순서로 전달된다
<br><br>

호출자의 레지스터들은 핸들러에 전달되는 `struct intr_frame`을 통해 접근 가능하다

반환값은 `RAX` 레지스에 넣는게 관례다

`struct intr_frame`을 통해 `rax`의 멤버를 수정해 값을 돌려줄 수 있다

<br>

___

<br>

구현해야 할 시스템 콜들이다

프로토타입은 `include/lib/user/syscall.h`를 포함한 사용자 프로그램에 보이는 인터페이스다

각 시스템 콜의 번호는 `include/lib/syscall-nr.h`에 정의되어 있다

___

### `void halt (void);`

`power_off()`를 호출하여 Pintos를 종료 (선언: `src/include/threads/init.h`)

교착 상태 등에 대한 정보를 잃을 수 있으므로 **드물게만** 사용되어야 한다

___

### `void exit (int status);`

현재 사용자 프로그램을 종료하고, `status`를 커널에 반환한다

부모가 이 프로세스를 wait하면 이 값이 반환된다 (아래 참조)

0은 성공, 0이 아니면 오류 의미한다 (관례적으로)

___

### `pid_t fork (const char *thread_name)`

현재 프로세스를 복제하여 이름이 `THREAD_NAME`인 새 프로세스를 만든다

*나중에 내용 추가*

___

### `int exec (const char *cmd_line);`

*나중에 내용 추가*

___

### `int wait (pid_t pid);`

*나중에 내용 추가*

___

### `bool create (const char *file, unsigned initial_size);`

*나중에 내용 추가*

___

### `bool remove (const char *file);`

*나중에 내용 추가*

___

### `int open (const char *file);`

*나중에 내용 추가*

___

### `int filesize (int fd);`

`fd`로 열린 파일의 **바이트 단위 크기** 반환

___

### `int read (int fd, void *buffer, unsigned size);`

*나중에 내용 추가*

___

### `int write (int fd, const void *buffer, unsigned size);`

*나중에 내용 추가*

___

### `void seek (int fd, unsigned position);`

*나중에 내용 추가*

___

### `unsigned tell (int fd);`

*나중에 내용 추가*

___

### `void close (int fd);`

*나중에 내용 추가*

___

<br><br>

## 추가 정보

시스템 콜 여러개 호출해도 안전하도록 동기화 해야 한다

특히, `filesys` 디렉터리에 제공된 **파일 시스템 코드**를 <br>
여러 스레드가 동시에 호출하는 것은 **위험하다**

그렇기에 시스템 콜 구현에서 파일 시스템 코드를 **임계 구역**으로 다루어야 한다

아직은 `filesys` 디렉터리 코드 수정하는 걸 권장하지 않는다
<br><br>

구현 이후 사용자 프로그램은 절대 OS를 오동작으로 몰아가면 안된다<br>
OS를 멈추는 유일한 방법은 `halt` 시스템 콜 호출이어야 한다

시스템 콜에 **잘못된 인자** 전달된 경우, 다음 중 하나로 대응해야 한다

**오류값 반환, 정의되지 않은 값 반환, 프로세스 종료**