별건 아니고 구현 하며 생긴 의문 이나 간단 정보다

# `syscall`

시스템 콜인데 이게 두개가 있다

하나는 `lib/user`안에 다른 하나는 `userprog`안에

하나는 유저 프로그램용이고 하나는 커널이 호출하는 용도다

비슷해보여도 계층과 역할이 다르다

커널에서 일하게 하는 거랑 실제 커널에서 일하는 거니 말이다


## 표로 보기

| 구분 | 위치  | 실행되는 곳    | 누가 호출?   | 하는 일    | 못 하는 일 / 주의         |
| ---------- | ---------------------- | --------- | ------------ | ---------- | -------------- |
| **유저용 래퍼** | `lib/user/syscall.c` (`lib/user/syscall.h`) | **유저 모드** | 유저 프로그램(C) | 함수처럼 보여도 실제로는 **레지스터(RAX=번호, RDI/RSI/RDX=인자…) 세팅 → `syscall` 명령**으로 **커널에 진입** | 커널 자료구조 접근 불가. 커널에서 이 헤더를 include하면 안 됨.                                                        |
| **커널 핸들러** | `userprog/syscall.c` (`userprog/syscall.h`) | **커널 모드** | CPU가 `syscall`로 진입하면 커널이 호출 | **번호 디스패치** → 포인터 검증/복사 → 파일디스크립터, 프로세스, 메모리 등 **실제 동작 수행** → **RAX에 반환값** 넣고 복귀(혹은 `exec/exit`처럼 **복귀 안 함**) | 유저 래퍼를 호출하는 게 아니라 **커널 내부 함수**(예: `sys_write`, `sys_exit`)로 처리해야 함. 유저 포인터 직접 역참조 금지(검증/복사 필요) |
