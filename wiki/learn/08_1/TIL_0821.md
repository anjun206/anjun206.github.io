오늘부터 TIL에 주관 많이 담을 예정이다

<br>

어차피 공부와 관련된 내용은 검색하는게 보다 정확하고 영양가 있을테니

기억을 되살리는 정도의 역할로 TIL쓰기 위해 말이다

<br>

이번주의 주제는 동적 메모리 할당이다

C의 malloc, calloc, realloc같은 걸 구현하는게 목적이다

<br>

흠...

<br>

니가해

<br>
<br>

안타깝게도 내가 해야 한다

C에 있는 거 걍 쓰지

첫날이니 만큼 가볍게 관련 단어들의 키워드들 위주로 정리했다

<br>

# 키워드 단어

[dmz, ZFOD](../../reviews/week7_word/dzm,zfod.md)라고 불리는 무요구 메모리 영역<br> (CSAPP 공식 번역인데 솔직히 좀 별로다 ㅇㅇ)


[메모리 할당 정책](../../reviews/week7_word/ma.md) **동적 메모리 할당기**(예: malloc)같은 애들이 힙에서 적절한 블록 찾는 방식이다


[페이징](../../reviews/week7_word/paging.md) 저번주 csapp 내용인데 이번주 키워드 단어 있길래 걍 한번더 간략히만 다뤘다

<br>
<br>

# 추가 : 내부 매크로, 상수


내부 매크로랑 상수도 추가로 적겠다

생각보다 중요한 내용이라 자주 봐야 할 듯 하다

기본적으로 CSAPP에서 설명하는 예제는 32비트 기반이고<br>
지금 구현할 기기는  64비트 기반이란 걸 염두해야 한다

그렇기에 32비트 기준 정리 한번하고 똑같은 내용 64비트로 적어 놓겠다

<br>

## 32비트

### 상수

- `WSIZE` 워드 크기 : 4바이트

- `DSIZE` 더블 워드 : 8바이트

- `CHUNKSIZE` 힙을 한번에 확장하는 기본 크기<br>
예) 1<<12 4096바이트

<br>

### 매크로

- `MAX(x,y)`<br>
  두 값 중 더 큰 값

  <br>

- `PACK(size, alloc)`<br>
  “크기 + 할당비트”를 **하나의 워드**로 결합 `alloc`은 보통 LSB(1비트)<br>
  예) `size | alloc`

  <br>

- `GET(p)` / `PUT(p,val)`<br>
  포인터 `p`가 가리키는 워드를 읽기/쓰기. (헤더/푸터 조작)<br>

  <br>

- `GET_SIZE(p)` / `GET_ALLOC(p)`<br>
  헤더/푸터 워드에서 **크기**와 **할당 여부** 추출

    - `GET_SIZE`는 하위 플래그 비트를 마스크로 제거

    - `GET_ALLOC`은 LSB만 확인

    <br>

- `HDRP(bp)` / `FTRP(bp)`<br>
  블록 포인터 `bp`(payload 시작 기준)로부터 **헤더/푸터 주소** 계산

  <br>

- `NEXT_BLKP(bp)` / `PREV_BLKP(bp)`<br>
  다음/이전 블록의 `bp` 계산. 연결 리스트 없이 블록 간 이동

  <br>

- `ALIGNMENT`, `ALIGN(x)`<br>
  정렬 단위와 올림 정렬. (보통 8 또는 16)<br>
  예) `ALIGN(x) = (x + ALIGNMENT-1) & ~(ALIGNMENT-1)`


<br>
<br>

## 표로 32비트와 64비트 비교

| 항목                                    |             32비트 |               64비트 |
| --------------------------------------- | ----------------: | -------------------: |
| 주소 폭                                 |             32-bit |              64-bit |
| 포인터 크기 (`void*`)                   |            **4 B** |             **8 B** |
| `size_t` 크기                           |            **4 B** |             **8 B** |
| 워드 크기(`WSIZE`, 보통 `sizeof(size_t)`) |            **4 B** |             **8 B** |
| 더블워드 크기(`DSIZE` = 2×`WSIZE`)          |            **8 B** |            **16 B** |
| 권장 정렬(`ALLOC`/ABI[^1] 관례)               |            **8 B** |            **16 B** |
| 헤더/푸터 한 워드 폭(보통 `size_t`)      |            **4 B** |             **8 B** |
| 정렬로 확보되는 하위 플래그 비트 수      | **3비트** (정렬 8B일 때) | **4비트** (정렬 16B일 때) |
| 크기 마스크 예시 (`GET_SIZE`)            |             `~0x7` |              `~0xF` |

<br>

하위 플래그 비트수가 바뀌는 이유는 이진수라 그렇다

**3비트(2³=8)** 가 항상 0 → 플래그 3비트 사용 가능

**4비트(2⁴=16)** 가 항상 0 → 플래그 4비트 사용 가능
 
정렬 단위 수가 8바이트(32비트), 16바이트(64비트)냐에 따라서<br>
하위 플래그 비트 수가 정해진다

<br>

예)

- 8바이트 정렬

    - `1000` = 8

- 16바이트 정렬

    - `10000` =16

<br>

만약 32바이트 정렬이면 5개 사용가능이다

<br>
<br><br>
<br><br>

___

[^1]: **ABI (Application Binary Interface)** : “바이너리 수준에서 프로그램/라이브러리/OS가 서로 맞물리는 약속”<br>
주로 호출 규약, 스택 정렬 기준, 자료형 크기/정렬 등등을 규정

