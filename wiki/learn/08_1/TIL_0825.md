# TIL 25

오늘의 목표는 묵시적 할당기인 동적 할당기를 명시적 할당기로 전환하는게 목표다

이중 연결리스트 방식이기에 pred/succ 만들어 연결해 줄거다

최소 할당 크기 변환도 고려해보았는데 16바이트 안에 다 들어가니까 문제 없을 거 같다

실제 가용 블록 될때에는 사용자가 알아서 쓸테니까 걍 페이지로드에 pred/succ 박아놓을 계획이다

뭐, 정 문제 생기면 페이지로드 초기화 명령어 넣으면 되겠지

<br>

## 목표

일단 바꿀 목표부터 정하고 이뤄나가야 겠다

- [ ] pred/succ 매크로
- [ ] 힙 익스텐드에 pred/succ 배치
- [ ] 배치과정에 리스트 연결 조작
- [ ] free 과정에 리스트 연결 조작
- [ ] 병합 과정에 리스트 연결 조작
- [ ] realloc 과정에 리스트 연결 조작

모아놓고 보니 전부 같은 소리긴 하다

<br>

## 1트

바로 들어가 보자

<br>

### pred/succ매크로

```c
/* 추가 확장으로 pred/succ */
#define PRED_FIELD(bp)    ((char *)(bp) + 0)
#define SUCC_FIELD(bp)    ((char *)(bp) + PSIZE)

/* pred/succ 접근 매크로 */
#define GET_PRED(bp)      ((void*)GET(PRED_FIELD(bp)))
#define SET_PRED(bp, x)   (PUT(PRED_FIELD(bp), (unsigned int)(x)))
#define GET_SUCC(bp)      ((void*)GET(SUCC_FIELD(bp)))
#define SET_SUCC(bp, x)   (PUT(SUCC_FIELD(bp), (unsigned int)(x)))
```

pred는 페이로드 시작이니 걍 bp로 가리키고 succ는 포인터 사이즈 만큼 이동해서 다시 가리키면 된다

그리고 값 접근하는 경우는 매번 타입 캐스팅하고 이런거 자신 없어서 한번에 다 정해줬다

값을 받고 쓸때는 void로 변환하고

저장할때에는 부호없는 정수 형식으로 저장한다고 보면된다

<br><br>

- [X] pred/succ 매크로
- [ ] 힙 익스텐드에 pred/succ 배치
- [ ] 배치과정에 리스트 연결 조작
- [ ] free 과정에 리스트 연결 조작
- [ ] 병합 과정에 리스트 연결 조작
- [ ] realloc 과정에 리스트 연결 조작

다음으로 가자

<br>

### 힙 익스텐드

뭐 건드려야 할지 모르겠어서

```c
SET_PRED(NEXT_BLKP(bp), bp);
SET_SUCC(bp, NEXT_BLKP(bp)); 
```
이거 2줄 추가하고 넘어갔다

다음 블록 에필로그 헤더면 어찌 될지 모르겠다

if문 넣어서 하고 싶은데 비효율적일까봐 일단 빼고 오류 생기거나 하면 고려해 봐야겠다

<br>

### 배치과정

배치 과정까지 오다 보니까 문제 발견했다

위에 코드 복붙 똑같은 걸 끼워 쓰다 보니<br>
`NEXT_BLKP`같은 걸 쓰면 다음 블록(물리적 위치) 이지 실제 연결리스트가 아닌 거시다...

그래서 매크로 다시 싹 고쳤다

<br>

## 2트

관련 매크로 수정하고 새로 만들어 보겠다

<br>

### 매크로

기존 것들은 그대로 유지하고 새로 추가했다

1. 현재 블록 리스트에서 제거하고 연결리스트 앞뒤끼리 연결

2. 블록 a, b 연결

3. 블록 a, b 사이에 c 넣기

<br>

이렇게 3개 만들었다

<br>

```c
/* bp를 free-list에서 제거: pred ↔ succ 서로 물리기 */
#define UNLINK(bp) do {                             \
    void* _bp  = (bp);                              \
    void* _pred = GET_PRED(_bp);                    \
    void* _succ = GET_SUCC(_bp);                    \
    if (_pred) SET_SUCC(_pred, _succ);              \
    if (_succ) SET_PRED(_succ, _pred);              \
} while (0)


/* a ↔ b 를 서로 물림 (NULL 허용) */
#define LINK(a, b) do {                          \
    if (a) SET_SUCC((a), (b));                   \
    if (b) SET_PRED((b), (a));                   \
} while (0)


/* bp를 앞뒤 사이에 넣기 */
#define INSERT_BETWEEN(prev, bp, next) do {      \
    SET_PRED((bp), (prev));                      \
    SET_SUCC((bp), (next));                      \
    if (prev) SET_SUCC((prev), (bp));            \
    if (next) SET_PRED((next), (bp));            \
} while (0)
```

<br>

### init

좀 이리저리 구른 결과 여기서부터 손봐야 된다는 걸 알아냈다

가용 리스트를 만들어 운용한다고 쳐도 앞에 프롤로그거나 뒤가 에필로그면 어떻게 운용할지 모르겠어서 말이다

그래서 새로 연결리스트용 포인터 헤드를 만들어줬다

```c
/* 리스트 헤드용 포인터 만듦 */
static void *free_head = NULL;
```

그리고 init도 LIFO 방식으로 업뎃 했다

```c
int mm_init(void)
{
    if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)-1)
        return -1;
    PUT(heap_listp + (0*WSIZE), 0);
    PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1));  // 프롤로그 헤더
    PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1));  // 프롤로그 푸터
                                                  // 실제 힙 확장하고 사용자 메모리 들어갈 곳
    PUT(heap_listp + (3*WSIZE), PACK(0, FL_ALLOC | FL_PREV_ALLOC));      // 에필로그 헤더 (힙 영역 마무리)
    heap_listp += (2*WSIZE);

    /* 리스트 포인터 초기화 */
    free_head = NULL;

    void *bp = extend_heap(CHUNKSIZE/WSIZE);
    if (bp == NULL) return -1;
    
    // extend_heap에서 만든 가용 블록을 free-list 헤드에 삽입 (LIFO)
    SET_PRED(bp, NULL);
    SET_SUCC(bp, free_head);
    if (free_head) SET_PRED(free_head, bp);
    free_head = bp;

    return 0;
}
```

새로 생긴 가용 블록을 리스트 맨 앞에 넣는 방식으로 처리

<br>


LIFO 쓸거라 관련함수 만들었다

해제나 이런거에 쓸려니까 하나 필요해서 말이다
```c
#define INSERT_FRONT(bp) do {                          \
    SET_PRED((bp), NULL);                              \
    SET_SUCC((bp), free_head);                         \
    if (free_head) SET_PRED(free_head, (bp));          \
    free_head = (bp);                                  \
} while (0)
```

<br>

### 힙 익스텐드

밥 먹고 와서 만들었는데...

```c
static void *extend_heap(size_t words)
{
    char *bp;
    size_t size;

    size = (words % 2) ? (words+1) * WSIZE : words * WSIZE;
    if ((long)(bp = mem_sbrk(size)) == -1)
        return NULL;

// 확장전 에필로그 바로 뒤
    unsigned int old_ep = GET(HDRP(bp));
// 직전 블록 할당 상태
    unsigned int prev = old_ep & FL_PREV_ALLOC;
// init 할때랑 동일
    PUT(HDRP(bp), PACK(size, prev));
    PUT(FTRP(bp), PACK(size, 0));
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, FL_ALLOC));

    bp = coalesce(bp);

    // LIFO 삽입 방식
    SET_PRED(bp, NULL);
    SET_SUCC(bp, free_head);
    if (free_head) SET_PRED(free_head, bp);
    free_head = bp;

// 병합
return bp;
}
```

LIFO를 매번 하기 어려워 힙익스텐드로 옮겼기에 init의 LIFO는 제거했다

<br>

### find fit

malloc은 딱히 건들 거 없어 보여서 내버려 두고 find_fit 손봤다

```c
static void *find_fit(size_t asize) {
    for (void *bp = free_head; bp != NULL; bp = GET_SUCC(bp)) {
        if (GET_SIZE(HDRP(bp)) >= asize) return bp;
    }
    return NULL;
}
```

널가드에다가 리스트 순회로 전환했다

first fit이면 충분 할 거 같아 안바꿨다

<br>

### 배치

```c
static void place(void *bp, size_t asize) {
    size_t csize = GET_SIZE(HDRP(bp));
    size_t remainder = csize - asize;
    if (remainder >= MIN_BLOCK) {
        UNLINK(bp);
        PUT(HDRP(bp), PACK(asize, GET_PREV_ALLOC(HDRP(bp)) | 0x1));
        char *nbp = NEXT_BLKP(bp);
        PUT(HDRP(nbp), PACK(remainder, FL_PREV_ALLOC));
        PUT(FTRP(nbp), PACK(remainder, 0));

        // nbp free-list에 삽입 LIFO
        INSERT_FRONT(nbp);

        // nbp 다음 블록 헤드 prev_alloc = 0
        PUT(HDRP(NEXT_BLKP(nbp)), GET(HDRP(NEXT_BLKP(nbp))) & ~FL_PREV_ALLOC);
    }
    else {
        UNLINK(bp);
        PUT(HDRP(bp), PACK(csize, GET_PREV_ALLOC(HDRP(bp)) | 0x1)); // 내 prev 유지 + alloc=1

        unsigned int nh = GET(HDRP(NEXT_BLKP(bp)));
        PUT(HDRP(NEXT_BLKP(bp)), nh | FL_PREV_ALLOC);               // 다음 헤더에 prev_alloc=1만 OR
    }
}
```

배치의 경우 UNLINK먼저 하고

분할해서 남는 것들은<br>
free-list에 LIFO로 추가하게 수정했다


<br>

### 병합

