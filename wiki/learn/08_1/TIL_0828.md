이번주가 ㄹㅇ 참트루로 중요하다고 한다

웹 서버 관련해서 공부하는 주간인데 실제로 자주 쓰이며<br>
예전에는(프레임워크 같은 거 없던) 이때 배우는 내용(CSAPP 11장)만으로 웹서버 관리했다고 한다

그렇기에 지금도 당연히 쓰이며 서버 런칭하고 웹관리 할때 꼭 알아야 할 중요한 주차라고 한다

당분간 수면 시간을 분할해야 하는 거 확정이다

<br>

일단은 csapp 교재 11장 부터 천천히 읽으며 흐름을 잡을 계획이다

<br>
<br>

# 11 네트워크 프로그래밍

## 11.1 클라이언트-서버 프로그래밍 모델

모든 네트워크 응용 프로그램의 기초라고 한다

별 건 없고 간단한 흐름 알고 가면 끝이다

*트랜잭션*이라고 하는 기본 연산인데

1. 클라이언트에서 *요청request* 서버에 보냄

2. 서버에서 요청을 적절히 조작함

3. 서버에서 *응답response*를 클라이언트로 보내고 대기

4. 클라이언트는 응답을 받고 처리

어려울 거 없다 이게 끝이다 ㅇㅇ

<br>

클라이언트와 서비스는 프로세스일 뿐이라 여러개 실행가능하다는 걸 염두하라고는 한다

<br><br>

## 11.2 네트워크 (Networks)

컴퓨터의 머신관점에서 네트워크는 그냥 어디 디스크 쯤으로 보여진다

그냥 데이터 I/O장치 말이다

<br>

네트워크는 규모에 따라 계층적으로 나눠진다

가장 작은 범위의 네트워크가 **LAN**이다<br>
LAN서버 할때 **LAN(Local Area Network)** 말이다

LAN 기술 중 가장 널리 사용되는 건 **이더넷(Ethernet)** 이다<br>
걍 네트워크 방식 중 일부라 생각하면 된다

이더넷은 이더넷 **세그먼트(segment)** 라는 물리 네트워크 단위를 사용하여 <br>여러 호스트(컴퓨터 등)를 일정 범위내에서 연결한다

각 호스트들을 **허브(hub)** 라는 중계장치에 연결한다<br>
허브로 보내진 비트들은 다른 호스트들에게 말이다<br>
누구에게 누가 보냈는지 등을 구별하기 위해 이더넷 어댑터엔 제조시 고요 번호인 **48비트 주소(일명 MAC 주소)** 가 있다<br>
 
보내질땐 프레임이라는 형식으로 보내져 출발지, 도착지, 데이터 길이 등 정보가 담긴 헤더와 실제 데이터가 들어있다

헤더는 모두 읽지만 실제 데이터는 도착지 주소(MAX 주소)의 호스트만 처리한다

여기서 이더넷 세그먼드들을 잔뜩 모아 더 큰 LAN도 구성가능하다<br>
이를 위해 **브릿지(bridge)** 라는 장치를 사용하여 세그먼트들을 연결하면<br> **브릿지드 이더넷(bridged Ethernet)** 이라는 확장 LAN이 된다

브릿지에선 목적지와 관련있는 세그먼트에만 데이터를 보내 효율 높인다

그리고 이러한 LAN들을 **라우터(router)** 라는 장비를 통해 연결 가능하다<br>
라우터는 다른 프로토콜이나 매체 쓰는 네트워크들을 연결해주는 역할 한다

라우터들끼리 연결은 **WAN(Wide-Area Network)** 라고 한다<br>

<img src="https://i.postimg.cc/pdPxfb43/LAN-WAN.png" alt="WAN_LAN" style="width: 50em; height: auto;">

<br><br>

라우터를 통해 네트워크 끼리 연결한 걸 internet이라고 하고 전세계적 IP기반 통합망을 Internet이라고 한다

인터넷의 중요 특성은 상호 호환되지 않는 네트워크들의 집합... 이라는 거다
<br>
어떻게 다른 것들끼이 데이터를 보낼 수 있냐?

이에 대한 해결책은 **네트워크 계층 프로토콜(network layer protocol)** 이라는 것이다

자꾸만 정리가 길어지는데 어쩔 수 없다<br>
자꾸 모르는 단어들이 기어나와서 말이다

아무튼, 여기서 그 유명한 **IP (Internet Protocol)** 가 나온다

IP주소로 해킹 말이다

IP 프로토콜은 호스트들에게 IP 주소르 부여해 이름을 정하고<br>
다른 데이터들끼리 데이터 전달가능케 한다

**패킷(packet)** 형식과 **라우팅(routing)** 형식으로 말이다

- 패킷:<br>
네트워크를 통해 전송되는 데이터 단위

- 라우팅:<br>
패킷이 목적지까지 가는 길을 찾는 과정

<br><br>

## 11.3 글로벌 IP 인터넷 (Global IP Internet)

**인터넷의 추상화**: <br>
전 세계 호스트가 **TCP/IP 스택(TCP/IP stack)** 위에서<br>
[**소켓 인터페이스(socket interface)**](#114-소켓-인터페이스-sockets-interface) 로 통신한다<br>


<br>

- **IP (Internet Protocol)**: <br>
네트워크에서 패킷을 어디로 보낼지 결정하는 기본 규칙

- **TCP (Transmission Control Protocol)**: <br>
신뢰적, 순서 보장, 양방향 바이트 스트림

- **UDP (User Datagram Protocol)**: <br>
비연결·비신뢰, 지연 민감(스트리밍 등 특수 용도)

애시당초 IP가 계층에서 한단계위라 UDP랑 TCP끼리 비교해야 한다<br>
UDP는 속도 위주, TCP는 정확성, 안정성 위주다


<br>

### **세 가지 핵심 개념**

1. **IP 주소(IP address)**: <br>
(IPv4) 32비트, **점-십진 표기(dotted-decimal)**

    - 네트워크 바이트 순서(**network byte order, big-endian**)

    - 변환: **htons/htonl ↔ ntohs/ntohl**, 문자열↔이진: **inet_pton/inet_ntop**
    
    - C 표현: `struct in_addr` 등. (IPv6은 128비트, 함수는 프로토콜 독립)

<br>

2. **도메인 이름(Domain name)** & **DNS (Domain Name System)**:

    - 계층 트리 (루트 “.” → **TLD**[^1] → 2차 도메인 → 서브도메인)

    - **이름↔IP 매핑**은 분산 DNS가 담당(1↔N, N↔1 모두 가능)

    - 예시: `localhost → 127.0.0.1`, 유명 서비스는 다중 IP로 **부하분산(load balancing)**

    - [DNS](../../reviews/week8_word/DNS.md) 추가정보

<br>     

3. **인터넷 연결(internet connection) & 포트(Port)**:

    - **연결**:<br>
    서로 다른 두 프로세스 간 TCP기반 **신뢰성 있는 양방향(full-duplex) 바이트 스트림**이다 (걍 TCP란 뜻)

    - **TCP 연결 식별자**: <br>
    IP에 포트 번호 붙이는 식으로 식별한다<br>
    (클라이언트 **`IP:포트`**, 서버 **`IP:포트`**) **소켓 쌍(socket pair)**

    - **일시적 포트(ephemeral port)**: 클라이언트 측, 보통 1024 이상을 커널이 임시 할당

    - **잘 알려진 포트(well-known port)**: 서버 측 고정 (예: HTTP 80, SMTP 25)

    - 하나의 서버 포트(예: 80)로도 **다수의 동시 연결** 처리 가능(소켓 쌍이 구분해줌)

<br><br>

# 11.4 소켓 인터페이스 (Sockets Interface)

- **소켓(Socket) = 통신 종단점(endpoint)**, 프로세스에선 **파일 디스크립터(file descriptor)** 처럼 취급

- **주소 구조체(Socket address structure)**

  - IPv4: **`struct sockaddr_in`** (`sin_family=AF_INET`, `sin_port`, `sin_addr`)

  - 역사적 이유로 함수 원형은 **`struct sockaddr*`** → **캐스팅 필요** (`(SA*)&addr`)

- **클라이언트 흐름**:
  `socket(AF_INET, SOCK_STREAM, 0)` → `connect(fd, server_sa, len)`(블로킹) → `read/write`(또는 **RIO**) → `close`

- **서버 흐름**:
  `socket` → `bind(listenfd, local_sa, len)`(IP/포트 고정) → `listen(listenfd, backlog)` →
  `accept(listenfd, &client_sa, &len)`(블로킹, **연결 전용 소켓 connfd 생성**) → `read/write` → `close(connfd)` → 반복

  - **대기 소켓(listening socket)**(listenfd)과 **연결 소켓(connected socket)**(connfd)을 **구분**

- **CS\:APP 헬퍼**

  - **`open_clientfd(host, port)`**: `getaddrinfo`로 주소 얻고 소켓+`connect`까지

  - **`open_listenfd(port)`**: `getaddrinfo`→ 소켓 → **`setsockopt(SO_REUSEADDR)`** → `bind` → `listen`

  - **`getaddrinfo/getnameinfo`**: 스레드 안전, **IPv4/IPv6 독립**, 구식 `gethostby*` 대체

- **견고한 입출력(Robust I/O, RIO)**

  - **짧은 읽기/쓰기(short count)**, **EINTR** 등 처리 위해 **`Rio_readn`, `Rio_writen`, `Rio_readlineb`** 사용 권장



___

[^1]: 최상위 도메인