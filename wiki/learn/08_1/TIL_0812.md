csapp 6단원 마무리

<br>

# 6.4 캐시 메모리

<br>

## 6.4.1 일반적인 캐시 메모리 구성

캐시는 S=2s개의 캐시 집합의 배열로 구성

각 집합은 E개의 캐시라인,

각 라인은 B=2b바이트듸 데이터 블록, 유효비트, 태그 비트로 구성된다

```css
[ Valid(유효비트) | Tag(태그 비트들) | Data Block(데이터 블록 B바이트) ]
```

- **데이터 블록** <br>
메모리에서 가져온 연속된 B바이트 실제 데이터<br>
CPU를 위한 데이터

<br>

- **유효 비트** <br>
현재 유효한지 표기하는 1비트
    - `0`이면 무효 -> 미스로 처리
    - `1`이면 사용 가능 -> 태그 비교로 최종 확인

<br>

- **태그 비트** <br>
어느 메모리 블록을 담고 있는지 식별용 라벨 <br>
같은 세트의 주소들 중 정확히 내 주소의 블록인지 판별 할 때 사용

<br>

## 6.4.2 직접 매핑 캐시

각 집합에 라인 하나만 있는 가장 간단한 캐시다

주소는 태그, 집합 인덱스[^1], 블록 오프셋[^2]으로 분할되어 사용

```mathematica
[ Tag(20) | Set Index(8) | Block Offset(4) ]
```

미스가 발생하기 쉬우며<br>
미스 발생시, 새 블록은 주소의 집합 인덱스에 따라 결정된 집합의 유일한 라인에 저장

<br>

### 접근 예시
32-bit 주소, 직접 매핑

- 총 캐시 용량 `C = 4KB`, 블록 크기 `B = 16B` → `b = log2(16)=4`

- 세트 수 `S = 4096 / 16 = 256` → `s = log2(256)=8`

- 태그 비트 수 `t = 32 - (8+4) = 20`


```mathematica
[ Tag(20) | Set Index(8) | Block Offset(4) ]
```

<br>

예) 주소 `0xCAFEBABE`를 쪼개면

- Block Offset = 하위 4비트 = `0xE` (블록 내부 14번째 바이트)

- Set Index = 그 다음 8비트 = `0xAB` (세트 171번)

- Tag = 상위 20비트 = `0xCAFEB`

즉 이 주소는 **세트 0xAB**로 가고, 그 세트의 유일한 라인에 **Tag 0xCAFEB**가 저장돼 있어야 히트

<br>

## 6.4.3 집합-연관 캐시

각 집합에 E개 이상의 라인이 있는 캐시

집합 선택은 직접 매핑 캐시와 동일

라인 매칭 시 확인해야 할 라인이 늘어 더 복잡해짐

미스 발생 시 교체 정책이 필요함

(예: LRU[^3], LFU[^4])

<br>

## 6.4.4 완전-연관 캐시

오직 하나의 집합(S=1)만 있는 캐시

집합이 하나기에 집합 인덱스 비트 같은 건 없고

주소는 태그와 블록 오프셋으로만 구성

크고 빠른 캐시를 만들기 불리해 작은 캐시에 사용됨

<br>

## 6.4.5 쓰기 문제 (Issues with Writes)

- **쓰기 히트(Write hits) 처리:**

    - **쓰기-통과(Write-through):** <br> 캐시와 다음 하위 레벨 모두에 즉시 데이터를 쓴다

    - **쓰기-뒤로(Write-back):** <br> 캐시에만 쓰고, 라인이 교체될 때까지 기다렸다가 다음 하위 레벨에 쓴다

- **쓰기 미스(Write misses) 처리:**

    - **쓰기-할당(Write-allocate):** <br> 미스된 블록을 하위 레벨에서 가져와 캐시에 로드하고 캐시에 쓴다

    - **비-쓰기-할당(No-write-allocate):** <br> 미스된 블록을 캐시에 로드하지 않고 하위 레벨에 직접 쓴다

<br>

이 2가지-2가지를 조합해 4가지 조합 사용가능하다

| 정책 조합    | 첫 번째 쓰기(미스)   | 두 번째 쓰기 |   메모리 쓰기 횟수 | 교체 시 추가 쓰기             |
| -------- | ------------- | ------- | ----------: | ---------------------- |
| WT + NWA | 메모리 직행        | 메모리 직행  |       **2** | 없음                     |
| WB + WA  | 캐시에 적재 후 캐시에만 | 캐시에만    | **0**(진행 중) | **1**(퇴출 시 write-back) |
| WT + WA  | 적재 후 캐시+메모리   | 캐시+메모리  |       **2** | 없음                     |
| WB + NWA | 메모리 직행        | 메모리 직행  |       **2** | 없음(미스마다 미리 메모리에 씀)     |



<br>

## 6.4.6  실제 캐시 계층 구조의 해부

캐시는 데이터 뿐만이 아닌 명령어도 저장한다

i/d로 분리해서 말이다

- 명령어만 저장하는 케시는 i-cache

- 데이터만 저장하는 캐시는 d-cache

- 둘을 함께 저장 하는 캐시는 통합(unifided) 캐시

<br>

Intel Core i7을 예시로 캐시 계층을 설명한다

- cpu 칩에 4개 코어

    - 각 코어에 L1 i-cache, L1 d-cache, L2 통합 캐시

        - 모든 코어가 칩 위의 L3 통합 캐시 공유

SRMA캐시 전부 CPU칩 내부에 있음

<br>

| 캐시         | 접근 시간(사이클) |   크기 C | 연관도 E | 블록 B |  세트 S |
| ---------- | ---------: | -----: | ----: | ---: | ----: |
| L1 i-cache |          4 |  32 KB |     8 | 64 B |    64 |
| L1 d-cache |          4 |  32 KB |     8 | 64 B |    64 |
| L2 통합      |         10 | 256 KB |     8 | 64 B |   512 |
| L3 통합      |      40–75 |   8 MB |    16 | 64 B | 8,192 |

<br>

### 분리형 L1의 이유

명령어 페치`i`와 데이터 접근`d`를 동시에 수행

읽기 중심`i`과 읽기/쓰기 혼합`d`으로 각기 최적화


### 계층별 성격

- **L1:** 매우 작고 빠름(≈4 cyc). 코어 전용, 레이턴시 최소화

- **L2:** 코어 전용 통합 캐시, **용량↑** **레이턴시↑** (≈10 cyc). L1 완충

- **L3:** 칩 내 **공유 통합 캐시**(≈40–75 cyc). 코어 간 데이터 **공유/재사용** 비용 절감

- 전부 **온칩 SRAM** → DRAM 왕복보다 훨씬 빠름

<br>

## 6.4.7 캐시 파라미터가 성능에 미치는 영향

캐시 성능 주요 평가 기준:

- **히트율(Hit rate):** 메모리 참조 중 히트의 비율

- **미스율(Miss rate):** 메모리 참조 중 미스의 비율
 
- **미스 페널티(Miss penalty):** 미스 때문에 추가로 필요한 시간

<br>

캐시크기가 **클수록 히트율🔺 히트시간🔺**

블록 크기가 크고 공간지역성 활용시<br>
**라인수🔻 히트율🔺 전송량🔺 패널티🔺**

연관도(한 세트 안에 들어갈 수 있는 캐시 라인 수)<br>
높아지면 **충돌 미스🔻 히트시간🔺 패널티🔺**

<br>
<br>
<br>

# 6.5 캐시 친화적인 코드 작성

프로그램 지역성 개선을 통해 캐시 미스율을 낮출 수 있다

- **지역 변수의 반복 참조:** <br>
컴파일러가 이들을 레지스터 파일에 캐시해 시간 지역성 🔺

- **스트라이드-1 참조 패턴[^5]:** <br>
캐시가 데이터를 연속적 블록으로 저장해 공간 지역성 🔺

<br><br><br>

# 6.6 함께 이해하기




<br><br><br>

____

[^1]: 블록(=캐시 라인) 안에서 몇 번째 바이트인지

[^2]: 어느 세트(줄)의 라인을 볼지

[^3]: (Least Recently Used) 가장 오래 안쓰는 라인 버리기 -> 시간적 지역성용

[^4]: (Least Frequently Used) 가장 적게 쓰인 라인 버리기 -> 자주 참조되는 핫데이터용

[^5]: 연속된 메모리 주소 한 칸씩(인접 원소) 차례로 접근하는 패턴