
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F246FC24F55612AAD13" alt="설명" style="width: 25em; height: auto;">


정답 같은 건 없고

이번 주차 malloc 구현 채점 기준을 대강 살펴보았다

내가 분석하기엔 어려워 AI의 도움을 받았다

<br><br>

# 채점 기준

<br>


## **채점 구조**

1. 각 트레이스를 돌리며 **정합성 검사** <br>
→ 정렬·힙 범위·페이로드 중첩 금지, `realloc` 시 이전 데이터 보존 확인<br>
통과해야만 점수 계산 진행된다

<br>

2. **Util(이용도)** <br>
= 트레이스 상의 최대 총할당 바이트 `hwm` ÷ 최종 힙 크기(`mem_heapsize()`)
<br>
즉 “이상적 패킹 대비 실제로 늘린 힙 크기”. `mem_sbrk`는 줄일 수 없어서 최종 brk가 힙 크기로 고정된다

<br>

3. **Thru(처리량)**<br>
  = 전체 연산 수 ÷ 실행 시간<br>
  실행 시간은 `fsecs(eval_mm_speed)`로 재고, 내부에서 사이클 카운터 기반 `fcyc`을 사용한다

<br>

4. **Perf index** <br>
= `UTIL_WEIGHT*avg_util + (1-UTIL_WEIGHT)*min(1, avg_throughput/AVG_LIBC_THRUPUT)` × 100<br>
즉 처리량은 libc 수준에서 포화

<br>

---

<br>

## **무엇을 올려야 하나? (우선순위)**

1. **분할(splitting) 조건**:<br>
남는 조각이 최소 블록 크기 미만이면 분할하지 않기 <br>
→ 내부 단편화·추가 힙 확장을 줄여 util🔺 (분모 억제)

2. **즉시 병합(coalescing)** 과 **prev_alloc 비트**로 **할당 블록의 푸터 제거** <br>
→ 메타데이터 오버헤드 축소로 util🔺, 캐시 효율로 thru도 보통🔺

3. **배치 정책**: <br>
단일 리스트 First-fit보다 **분리 적합(세그리게이티드 리스트)** 가 대체로 util/throughput 모두 유리

4. **realloc 최적화**: <br>
뒷블록이 비어있으면 **동일 위치 확장·축소** 우선 <br>
→ 추가 `mem_sbrk` 방지로 util🔺, 복사 감소로 thru🔺

5. **CHUNKSIZE 튜닝**: <br>
너무 크면 불필요한 힙 증가로 util↓, 너무 작으면 `extend_heap` 빈번 <br>
→ thru↓<br>
**트레이스별 균형점이 있어 보조 레버**로 사용