csapp 이어서 하겠다

개같은 거 졸라게 많다

아무래도 이것저것 고유명사 비스무리한게 많아

하나하나 다 정리해가며 짚어야 오히려 이해하기 편할 거 같다



# 11.4 소켓 인터페이스 (The Sockets Interface)

소켓 인터페이스는 프로그래머가 네트워크 통신을 구현하기 위해 사용하는 표준 API[^1]

<br>

## 11.4.1 소켓 주소 구조체 (Socket Address Structures)

소켓 함수들은 프로토콜에 따라 다른 주소 체계를 지원해야 하므로, 이를 위해 **소켓 주소를 표현하는 공용 구조체**를 사용

- **IPv4 구조체**: `sockaddr_in`<br>
  16바이트 크기

    - **주소 패밀리**: `sin_family`<br>
      IPv4 주소체계라는 의미

    - 16비트 **포트 번호**: `sin_port`

    - 32비트 **IP주소**: `sin_addr`

<br>

- 일반 주소 구조체: `struct sockaddr`<br>
  껍데기 구조체 (주소 데이터 담으려 만든게 아님)

    - **소켓 주소 구조체 포인터**: `struct sockaddr *`<br>
      void없었을때의 잔여, **매개변수 역할**을 한다<br>
      [자세히](../../reviews/week8_word/sockaddr.md)

<br>

- 주소 창고: `sockaddr_storage`<br>
  IPv4, IPv6 등 여러 종류의 소켓 주소 저장하기 위한 큰 공용 구조체다<br>
  클라이언트 주소 받을때 `struct sockaddr_storage clientaddr;`으로 선언하면 IPv4/IPv6에 상관없이 쓸 수 있다<br>
  이 구조체는 필요 시 `sockaddr *`로 캐스팅해 사용한다

<br>

- 커널 vs 프로그램:<br>
  커널에선 소켓을 통신의 끝점으로 보지만<br>
  사용자 프로그램에선 단순 파일 디스크립터[^2] 취급한다

<br><br>

## 11.4.2 `socket` 함수 (The socket Function)

`socket()` 함수는 새 소켓 생성해 **파일 디스크립터(fd)** 를 반환한다

소켓 생성 기 통신에 사용할 **도메인(domain)**, **타입(type)**, **프로토콜(protocol)** 을 지정한다

- **함수 원형:** `int socket(int domain, int type, int protocol);` 으로 정의<br>
  성공 시 **소켓 디스크립터 반환**<br>
  이는 이후 I/O 함수에 사용 가능

<br>

- **도메인 (주소 체계)**:<br>
  첫 번째 인자는 **주소 체계** 지정

    - `AF_INET`: IPv4
    - `AF_INET6`:IPv6
    - `AF_UNIX`: 로컬 유닉스 도메인

<br>

- **소켓 타입**:<br>
  두 번째 인자는 통신의 **특성**을 지정

    - `SOCK_STREAM`은 TCP처럼 연결 지향적이며 신뢰적인 바이트 스트림을 의미

    - `SOCK_DGRAM`은 UDP처럼 비연결성[^3] 데이터그램[^4] 방식을 의미

<br>

- **프로토콜**:<br>
  세 번째 인자는 특정 프로토콜 지정하는 값이나, 보통 하나의 도메인-타입 조합에 가능한 프로토콜이 하나뿐이므로 `0`을 주어 **기본 프로토콜 선택**을 사용

<br>

소켓은 초기에 완전히 열린 상태가 아니라 바로 데이터 읽기/쓰기가 불가능하다
<br>
클라이언트의 경우 `connect()` 호출을 통해 연결해야 하고
<br>
서버의 경우 `bind()`로 주소를 지정하고 `listen()`으로 대기 상태로 만들어야한다

**프로토콜 독립성**:<br>
소켓 만들 때에 `AF_INET`등을 넣는 대신에 <br>
**getaddrinfo** 같은 함수를 활용하여 도메인과 타입을 동적으로 얻어내는 것이 권장된다

이를 통해 IPv6 등도 지원 가능케 된다

<br><br>

## 11.4.3 `connect` 함수 (The connect Function)

**클라이언트 측**에서 사용하며 연결을 요청한다<br>
**호출 시 블로킹**되어, 상대 서버와의 연결이 완전히 설정되거나 에러가 발생할 때까지 반환하지 않는다<br>
연결에 성공하면 소켓은 **통신 가능한 상태(established state)** 가 되고, 이후 해당 소켓 디스크립터를 통해 데이터를 주고받을 수 있다<br>
실패할 경우 -1을 반환하며 `errno`에 에러 정보를 남긴다

<br>

- **함수 원형**: `int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);` 형식<br>
  반환값은 성공시 `0`, 실패시 `-1`이다

    - `sockfd`는 `socket()`로 생성한 클라이언트 소켓

    - `addr`는 **서버의 소켓 주소**

    - `addrlen`은 주소 구조체의 크기

<br>

- **매개변수 준비**:<br>
  `addr` (주소)인자는 보통 서버의 IP와 포트를 설정한 뒤 그 포인터를 캐스팅한 것이다<br>
  이때 IP 문자열을 이진수로 변환(`inet_pton`)하거나 DNS이름을 IP로 해석 (`getaddrinfo`)하는 선행 작업 필요

<br><br>

## 11.4.4 `bind` 함수 (The bind Function)

`bind()` 함수는 서버 측에서 사용<br>
생성된 소켓에 **로컬 주소(아이피와 포트)를 할당**<br>
이를 통해 자신의 소켓이 특정 포트 번호를 수신 대기하도록 커널에 알리고, 필요하면 네트워크 인터페이스(특정 IP나 모든 IP)에 바인드할 수 있다<br>
없이 `listen()`하면 임의의 포트 할당하지만<br>
서버는 클라가 아는 **고정 포트** 사용해야 하므로 `bind()` 호출 필수적

- **함수 원형**: `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`<br>
  정상 수행 시 `0`, 실패시 `-1` 반환

    - `sockfd`는 서버가 생성한 소켓

    - `addr`은 바인드할 자신의 주소

    - `addrlen`은 주소 구조체 크기

<br>

- 실패하는 경우:<br>
  포트 충동 시 실패한다















<br><br><br>

___

[^1]: 애플리케이션 프로그래밍 인터페이스(Application Programming Interface)<br>
서로 다른 소프트웨어들이 통신하고 데이터를 교환할 수 있도록 하는 규칙과 프로토콜의 집합

[^2]: 특정한 파일에 접근하기 위한 추상적인 키

[^3]:비연결성 (Connectionless):<br>
데이터를 전송하기 전에 미리 연결을 설정하는 과정(호 설정)이 필요 없다

[^4]: 데이터그램 (Datagram):<br>
데이터가 데이터그램이라는 독립적인 패킷 단위로 분할되어 전송

[^5]: 