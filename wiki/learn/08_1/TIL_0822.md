오늘도 TILTIL이다

<br>

시작은 가용 리스트다

<br>

# 가용 리스트

가용 리스트란?

- 할당 가능한 블록들의 모음을 가리킨다

<br>
<br>

## 블록?

힙에 존재하는 블록들을 말이다

어제 덜 다룬 것 같은데 힙(heap임 엉덩이 아님)에 있는 메모리는 블록 단위로 관리 된다

1. **헤더(header):** 블록 크기, 할당 여부 저장

2. **페이로드(payload):** 실제 사용자에게 제공되는 공간

이런식으로 말이다

<br>

그리고 블록은 상태에 따라 두가지로 나뉜다

- **할당 블록(Allocated block)**

    - 사용자가 `malloc`으로 요청해서 프로그램이 쓰고 있는 상태

    - 힙 관리자가 임의로 건드릴 수 없다

- **가용 블록(Free block)**

    - `free`로 반환되었거나 아직 누구에게도 주지 않은 상태

    - 추후 `malloc ` 요청이 들어오면 이 블록이 재사용된다

<br>

<br>

아무튼 다시 가용 리스트로 돌아오면 가용리스트도 3갈래로 쪼개진다

<br>

<br>

## 가용 리스트 종류

<br>

### 1. **암시적 가용 리스트 (Implicit Free List)**

- 모든 블록 순회하며 가용 블록 찾는 법

- 블록 크기 정보가 다음 블록 주소를 암시적으로 알려준다 해서 암시적 가용리스트

### 2. **명시적 가용 리스트 (Explicit Free List)**

- 가용 블록들만 따로 묶어 탐색하는 방식이다

- 연결 리스트 방식으로 구현 (주로 이중 연결 리스트) 

### 3. **분리 가용 리스트 (Segregated Free Lists)**

- 가용 리스트 여러개를 크기 별로 운용하는 방식

- 분리 가용 리스트의 **변형**

    - **단순 분리 저장**

        - 각 크기 클래스의 가용 리스트에 항상 동일 크기 블록만 저장

    <br>

    - **분리 적합**

        - 크기 범위 안에 다양한 크기 블록 저장

        - 크기에 맞는 블록 검사하고 있으면 할당하고 남은 조각은 맞는 범위로 이동

        - 검사해도 없을 경우 다음 크기 클래스 검사

<br>

추가로 **버디 시스템**이라는게 있다

분리 가용 리스트의 한 에라고 한다

블록 크기를 2의 거듭제곱으로 제한하고 크기별 가용리스트 유지

요청 받은 거보다 바로 다음으로 큰 $2^k$블록 할당하고 블록 없으면 한단계 윗놈을 반 갈라 하나주고 하나 리스트에 넣는다고 한다

으음...

특수 상황에서 좋다고 한다

<br>

깨달음을 하나 얻었다

앞에서 배웠던 링크드 리스트 구조를 어디에 쓰나 했더니 이런데에 쓸 수 있다니...

세그리게이티드 뭐시기 막 이러길래 어지러웠는데

뭔지 알게 되어버렸다...

이거 너무 강해지는 거 아닌가 걱정이다...

스티브 잡스가 벌벌떨고 빌게이츠가 눈치보는!!!

아무튼, 메모리 할당과정에 대해 이해도가 높아졌다

<br><br>

<br>

# 메모리 할당 과정, 분할 전략

메모리 할당해주는 법이다

요청 받은 크기 이상의 가용 블록 찾아 할당 해줘야 하는 거 말이다

대강 이런 절차라고 한다

1. 요청 크기 조정

    - 사용자의 요청 데이터 + 메타 데이터 + 정렬 패딩으로 **실제 필요한 블록 크기 계산**

<br>

2. 적합한 가용 블록 탐색

    - [메모리 할당 정책](../../reviews/week7_word/ma.md)이 여기서 쓰인다 어떤 블록 쓸지 찾는다

<br>

3. 블록 분할

    - 적합한 블록 찾았고 블록이 요청 크기보다 충분히 크면 남는 부분 분할할지 결정한다<br>
    충분의 기준은 최소 블록 크기 이상이냐 이다

    - 보통 분할하고 별도의 가용 블록으로 유지한다

    - 안하면 더 편하지만 내부 단편화가 늘어난다

<br>

4. 블록 할당 마킹

    - 선택된 블록을 할당된 상태로 표시한다

<br>

5. 하프 확장