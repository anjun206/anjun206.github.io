새로 보이스 샘플 추천 알고리즘 만들어야 한다

```txt
현 파이프라인
VAD → diarization(pyannote) → STT(WhisperX) → 번역(Gemini) → TTS(CosyVoice2) → Sync → Mux
```

일단 이렇게 생긴 파이프라인인데 이것부터 좀 손봐야 한다

<br>

```txt
미래? 파이프라인
VAD → diarization(pyannote) → STT(WhisperX) → 번역(Gemini) → TTS(CosyVoice2) → Sync → Mux

                            ↑ 여기           ↑ 아니면 여기
```

화자 분리, 혹은 STT 이후에 해당 알고리즘을 넣는게 좋을 거 같다<br>
(위 그림)

보다 명확히하면 로직 만들고 이를 끼워넣는 느낌일 거다

번역 들어가서도 보이스 추천 받는것도 하는게 더 나으니 말이다

<br>

어떻게 만들지는...

완성되고 흘러갈 흐름 망상해보면 좋다

1. 파일 업로드

2. 업로드 설정에서 대체 음성 체크

3. 각 화자별 음성 임베딩 추출

4. TTS 이전 음성 샘플로 유사도 높은 음성 뽑기

5. 각 화자한테 새 음성 매핑해서 TTS

이런 흐름 하나랑

1. 편집기 들어감

2. 보컬트랙에서 보컬 변경할때 자동 추천 버튼 클릭 (혹은 그냥 추천)

3. 유사한 음성 추천

이런 흐름이 될 거 같다

<br>

추가적으로 생각하며 흐름 굳히는 중인데

스피커 임베딩하는 과정은 워커에서 해주면 된다

보이스 샘플 업로드 할때와 풀파이프라인 돌떄 모두 워커 거치니 이때 단계 하나 추가해주면 끝

임베딩 된 이후의 정보로 비교해서 추천해주는건 프론트단에서도 해결할 수 있는 문제라서 괜찮다

임베딩 데이터 저장하고 잘 관리하는게 핵심인 거 같다

기존 셀프 참조 음성 데이터 저장 위치에 임베딩 같이 저장해준다고 가정하면...

대체할 음성들은 어디에 저장해야 하나 싶다

...

다행히 그건 다른 폴더에 저장하는 곳이 있었다

걍 여기에 하나 추가하면 될 듯?

<br>

추가 고민 결과 이렇게 구상할거다

```txt
voice-samples/
  ├── tts/          # 유저에게 들려줄 TTS 결과
  ├── samples/      # 샘플로 쓸 원본 .wav
  └── embeding/     # (embedding) 언어별 인덱스 .json
      ├── ko/
      ├── en/
      └── ja/
```

이런식으로 구성해서

`samples`에는 보이스 클로닝 할때 넣어줄 원본 .wav 파일

`tts`에는 유저에게 들려줄 TTS 예시 .wav 파일

그리고 `embeding`에 각 언어별 폴더 만들어주고 임베딩 데이터랑 샘플 id, 원본 .wav 파일의 키값을 넣어줄거다

<br>

흐름은 보이스 샘플 업로드 시

samples에 .wav 파일 업로드하고 TTS만들어 tts에 업로드

이후 스피커 임베딩을 통해 해당언어의 폴더의 임베딩 인덱스 파일에 저장한다

풀 파이프라인 흐름은 해당 언어 임베딩 인덱스 파일 가지고 데이터 비교해 찾아서 코사인 유사도 높은 샘플 추천해주면 된다
