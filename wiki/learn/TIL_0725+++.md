
<br><br>
안타깝게도 그런 거 없다
<br><br><br>
있었으면 나혼자만 알거다 ㅇㅇ

<br><br><br>


# 3.3 데이터 형식
인텔은 워드라는 용어를 16비트를 가리킬때 썼다 (그때엔 16비트가 최신이었다)

그치만 이젠 64비트까지 와버렸고 이를 "쿼드 워드"라 부른다

32비트는 "더블 워드"다

<br>

| **x86-64에서의 C 기본형 데이터 표현** |
| C 선언     | Intel 데이터 타입     | 어셈블리 접미사 | 크기 (바이트) |
| -------- | ---------------- | -------- | -------- |
| `char`   | Byte             | `b`      | 1        |
| `short`  | Word             | `w`      | 2        |
| `int`    | Double word      | `l`      | 4        |
| `long`   | Quad word        | `q`      | 8        |
| `char *` | Quad word (포인터)  | `q`      | 8        |
| `float`  | Single precision | `s`      | 4        |
| `double` | Double precision | `l`      | 8        |
> tip: 64비트 시스템에서 포인터는 모두 8바이트다

## 부동소수점 수
부동소수점 수는 두 가지 주요 형식으로 제공된다

- **float**: 단정도(single-precision), 4바이트

- **double**: 배정도(double-precision), 8바이트

<br><br>
(대충 인텔에서 과거에 쓰던 특별한 연산 방식 설명)

(이식성 구리고 지원 부족해 사용하지 말라는 내용)

<br><br>

## 어셈블리 접미사

어셈블리 명령어의 경우,<br>
대부분 피연산자의 크기를 나타내는 한 글자 접미사를 가진다
<br><br>
예시)

- `movb`: 바이트 이동 (1B)

- `movw`: 워드 이동 (2B)

- `movl`: 더블 워드 이동 (4B)

- `movq`: 쿼드 워드 이동 (8B)

<br>

`1`은 long의 약자로 32비트 값을 가리킨다

특이사항 : <br>
**어셈블리 코드에서 `1`은 4바이트 정수와 8바이트 실수(double)** 모두 사용!!!

하지만 부동소수점 연산은 전혀 다르기에 혼동되지 않으니 걱정 안해도 된다