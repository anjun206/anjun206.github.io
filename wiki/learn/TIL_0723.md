<br>

csapp 2.1 요약 리부트다
<br><br>

2진법 쪽을 덜 다룬 것 같아
<br><br>

내용 보충하고 새로 요약했다
<br><br>
바로 건강 요약
<br><br>
<br>

# 2.1 정보의 전달
컴퓨터는 `0`,`1` 2진수를 사용한다<br>
8bit가 1byte다<br>
bit 하나가 `0`,`1` 둘 중 하나 표현한다<br><br>

# 2.1.1 16진수 표시
1byte를 2진수로 표현해보면 8bit니...
<br><br><br>
`[ 0 0 0 0 0 0 0 0 ]`
<br><br><br>
이렇게 된다
<br><br><br>
8비트로 표현가능한 수를 10진수로 나타내면 255다
<br><br><br>
$2^8$승이니 말이다<br>
256은 어디다가 빼먹었냐?
<br>
그건...
<br><br><br>
0이랑 바꿔먹었다
<br><br><br>
1~256 대신 0~255를 택했다고 볼 수 있다 ㅇㅇ
<br><br><br>
근데 2진수는 보기 ㅈ같으니
<br><br><br>
이를 좀 완화하고자 16진수를 쓴다
<br><br><br>
16진수는 0 ~ 10 + A, B, C, D, E, F 를 쓰는 방법이다
<br><br>
2와 16... 뭐가 오지 않는가?
<br><br><br><br>
그렇다.
<br><br><br><br>
2를 4번 곱하면 16이다
<br><br><br>
지랄말라고 하지말고 들어봐라
<br><br><br>

비트 하나는 `0`,`1`을 표현하는 2진수다
<br><br>
즉, 비트 4개로 16진수를 **표현가능!** 하다는거다
<br><br>
1바이트로 16진수 2개가 표현가능하고 말이다<br>
(1바이트는 8비트니까 소곤소곤)
<br><br><br>
옛날에 모바일 게임 크랙좀 해본 사람들은 알겠지만
<br><br><br>
게임 파일 까보면 `0E` `AC` `F3` `4E` 등 이따구로
<br><br>
잔뜩 있는 걸 알수 있는데 이게 그 흔적이다
<br><br><br>
그럼 마지막으로 진수 변환법만 알려주고 다음으로 넘어가겠다
<br>
___
| 변환 종류      | 변환 방법/설명                    | 예시                |
| ---------- | --------------------------- | ----------------- |
| 10진수 → 2진수 | 2의 제곱수의 합으로 표시              | 218 → 0b11011010  |
| 2진수 → 10진수 | 각 자릿수에 2의 거듭제곱을 곱해 모두 더함    | 0b11011010 → 218  |
| 2진수 → 16진수 | 4비트씩 끊어 각 부분을 16진수 한 자리로 변환 | 0b11011010 → 0xDA |
| 16진수 → 2진수 | 각 자리별로 4비트씩 2진수로 풀어서 합침     | 0xDA → 0b11011010 |
___
<br>
<br>
<br>

# 2.1.2 데이터의 크기
모든 컴퓨터는 워드 크기[^1]를 규격으로 가지고 있다<br>
주소값의 정규크기는 워드 크기를 따라가고 말이다<br><br>
C언어는 여러가지 데이터 포맷[^2]을 지원하는데<br>
아래는 각 타입별 데이터 크기다
<br><br>
___
| 자료형                       | 크기 (32bit) | 크기 (64bit) | 비고                   |
| ------------------------- | :--------: | :--------: | -------------------- |
| `char`, `unsigned char`   |   1 byte   |   1 byte   |                      |
| `short`, `unsigned short` |   2 byte   |   2 byte   |                      |
| `int`, `unsigned`         |   4 byte   |   4 byte   |                      |
| `long`, `unsigned long`   |   4 byte   |   8 byte   | 32/64bit에 따라 다름      |
| `int32_t`, `uint32_t`     |   4 byte   |   4 byte   |                      |
| `int64_t`, `uint64_t`     |   8 byte   |   8 byte   |                      |
| `char *` (포인터)            |   4 byte   |   8 byte   | 주소값, 32/64bit에 따라 다름 |
| `float`                   |   4 byte   |   4 byte   |                      |
| `double`                  |   8 byte   |   8 byte   |                      |
___

<br>
<br><br>

# 2.1.3 주소지정과 바이트 순서
바이트의 정렬을 알려주겠다.
<br><br>
리틀 엔디안(인디안 아님)과<br>
빅 엔디안 방법이 있다<br>
<br>
별건 아니고 오름차순 내림차순 이라 보면 된다
<br><br>
```py
# ex) 어떤 데이터의 바이트 배열이 0x12345678 이라고하면
little endian 방식: 78 56 34 12
big endian 방식: 12 34 56 78 
```
이-지 하다
<br>
두개씩 끊는 이유는 말했듯이 byte단위로 무빙해야 되기 때문이다
<br><br>
둘 중 뭐가 좋냐 물어보면...<br>
<br>
딱히 상관 없으니 일관성 있게 하나만 사용하라고 한다
<br><br>
그치만<br>
리틀 엔디안이 대중적이고<br>
절삭 속도가 좀 더 빠르다고 한다
<br><br>
이 두가지 배열의 차이는 딱 3가지 상황에서만 조심하면 된다
<br><br>
1. 네트워크를 통해 데이터를 전송할때

    - 0x111222 보내고 0x333444를 보내고 합쳐야 하는데...

    - 받는쪽에선 0x222111, 0x444333를 받아 이미지가 깨진다

<br>

2. 데이터를 살펴볼 때

    - 어셈블리어로 데이터 배열을 까볼때 엔디안 방식을 확인해야한다

<br>

3. 타입변환 할때

    - int에서 float이나 pointer등으로 변환 할때

    - 비트 해석 방식이 바뀌니 이를 감안해야 한다

<br>

# 2.1.4 스트링의 표시
스트링(str)은 문자열을 의미한다<br><br>
항상 마지막에 *null* 문자`('/n')`를 넣어줘야 한다<br><br>
각 문자는 아스 키코-드로 인코-딩 된다<br><br>
예시)<br>
```
                       null 문자
                           ↓
"12345" -> 31 32 33 34 35 00
```
<br><br>

# 2.1.5 코드의 표현
우리가 고급언어(python, c++ 등)로 막 분리해놔도
<br><br>
컴퓨터에겐 `0`, `1`로 이루어진 숫자 덩어리니
<br><br>
다른 머신이나 운영체제로 가면
<br><br>
박살난다는 내용이다
<br><br>
<br>

# 2.1.6 부-울, 혹은 불 대수
불, 혹은 부울이라 불리는 bool에 대해서다<br><br>
간단히 말하면 true, false 판별이다
<br><br><br>
더 궁금하면 연산자까지 알려주겠다<br>
안궁금하면 다음장가도 큰 상관 없다
<br><br>
<br>
___
| 연산자 |  기호 | 연산식   | 결과 설명                       | 예시 (A=0, B=1)    |            |
| :-: | :-: | :---- | :-------------------------- | :--------------- | ---------- |
|  OR |  `\|`    | A \| B                      | 둘 중 하나라도 1이면 1   | 0 \| 1 → 1 |
| AND | `&` | A & B | 둘 중 하나라도 0이면 0 (둘 다 1이어야 1) | 0 & 1 → 0        |            |
| XOR | `^` | A ^ B | 두 값이 다를 때만 1                | 0 ^ 1 → 1        |            |
| NOT | `~` | \~A   | 0 → 1, 1 → 0 (반전)           | \~0 → 1, \~1 → 0 |            |
___
<br><br><br>

# 2.1.7 C에서의 비트수준 연산
비트의 연속을 비트 벡터라 한다<br><br>
그리고 비트 벡터끼리 연산을 C에서 지원한다
<br><br>
(개구리 따봉하는 콘)
<br><br>

# 2.1.8 C에서의 쉬프트 연산
어려운거 없고 >> 면 오른쪽으로 비트 이동, << 왼쪽으로 비트이동이라는 뜻이다 ㅇㅇ
<br><br><br>
다만 >>할때 논리 우측 쉬프트, 산술 우측 쉬프트가 있는데,
<br>
논리 우측 쉬프트는 빈자리를 0으로 채우는것,<br>
산술 우측 쉬프트는 MSB라고하는 최상위 비트 값으로 채운다<br><br>
맨 왼쪽이 0이면 MSB는 0 맨 왼쪽이 1이면 MSB는 1.<br>
이런식 ㅇㅇ;;<br><br><br>
___
예시)
___
|   연산  | 입력값(8bit) | 결과(2비트 우측 쉬프트) | 결과(십진수) |
| :---: | :-------: | :------------: | :-----: |
| 논리 우측 |  11101000 = (-24) |    00111010    |    58   |
| 산술 우측 |  11101000 = (-24) |    11111010    |    -6   |
___
<br>
보통 부호형 연산할때 값 보존을 위해서 산술 우측 쉬프트를 사용한다
<br><br><br><br>
여기까지만 해도 양이 꽤 되니 2.2는 다음 글에서 다루겠다
<br><br>
컴퓨터 gosu가 될꺼야
<br><br><br><br><br><br>
___

[^1]: 컴퓨터 시스템에서 한 번에 처리 가능한 데이터 크기

[^2]: 정보를 표현하고 저장하는 형식