# 포인터

- **메모리 주소를 저장하는 변수**

- 어떤 값(변수)이 저장된 **위치(주소)** 를 저장한다

```c
int a = 10;      // 변수 a에 10 저장
int *p = &a;     // p는 a의 주소를 저장(포인터 변수)
```

<br><br>

## `&` 연산자 (주소 연산자)

- 변수 앞에 붙이면, 그 **변수의 주소값을 반환**

- **변수의 주소를 물을 때 사용**

```c
int a = 10;
printf("%p", &a);  // a의 메모리 주소를 출력
```

- `&a`는 **a의 주소**

<br><br>

## `*` 연산자 (간접 참조/역참조 연산자)

- 포인터 변수 앞에 붙이면, 그 **주소에 저장된 실제 값**을 읽거나 쓸 수 있음

- 주소에 있는 **값을 가져오거나** 주소에 **값을 쓸 때** 사용

```c
int a = 10;
int *p = &a;  // p는 a의 주소
printf("%d", *p); // p가 가리키는 곳의 값(a의 값) 출력: 10

*p = 20;      // p가 가리키는 곳(a)에 20 저장
printf("%d", a);  // a: 20
```

<br><br>

## 연산자 요약

| 기호  | 역할     | 예시       | 의미                |
| --- | ------ | -------- | ----------------- |
| `&` | 주소 얻기  | `&a`     | a의 주소             |
| `*` | 값 가져오기 | `*p`     | p가 가리키는 곳의 값      |
| `*` | 포인터 선언 | `int *p` | int형 주소를 저장하는 포인터 |


## DP와 연관

포인터 연산자와 직접적인 연관은 없다만

DP 구현 과정에서 자주 등장한다

<br>

`C`나 `C++`에서 사용하니 파이썬을 배우고 있는 지금은

대충 넘어가겠다

<br><br>

## 파이썬과의 관계

### 파이썬 변수는 '값'이 아닌 '객체의 참조(주소)'를 저장한다

- 실제 값이 아닌 객체가 저장된 메모리 위치를 가리킨다

- 모든 변수는 객체의 주소를 참조한다 볼 수 있다

#### 예시

```py
a = [1, 2, 3]
b = a        # b는 a가 가리키는 곳(리스트)을 똑같이 참조
b[0] = 100
print(a)     # [100, 2, 3]  ← b를 바꿨더니 a도 바뀜
```

<br>

___

<br>

### 파이썬에는 ‘주소 연산자(&)’나 ‘역참조 연산자(*)’는 없다

- 파이썬은 메모리 주소를 직접 다루는 연산자는 없음

- 주소를 직접 건드릴 수는 없지만,<br>
**id(변수)** 함수로 "메모리 주소"를 확인할 수 있다

#### 예시

```py
a = 10
print(id(a))  # a가 가리키는 객체의 주소(고유 id)
```

<br>

___

<br>

### 값이 아니라 참조가 복사된다

- 리스트, 딕셔너리, 객체 등 ‘가변 객체’는 복사해도 같은 곳을 가리킴

- "포인터로 전달되는 느낌"과 유사

- 함수 인자 전달도 **참조에 의한 전달(call by object reference)**

#### 예시

```py
def f(x):
    x[0] = 99

a = [0, 1, 2]
f(a)
print(a)  # [99, 1, 2] ← 함수 안에서 바꿔도 반영됨
```

<br>

___

<br>

### 파이썬은 메모리 주소 연산이나 포인터 산술 불가

- 파이썬에선 `*`, `&`로 메모리 직접 조작 불가

- 위험하지 않고, 더 안전하게 추상화된 방식

<br>

___

<br>

### 결론

- **파이썬은 C/C++처럼 직접 포인터 연산을 하진 않는다**

- 하지만 **모든 변수는 사실상 "객체에 대한 참조(간접주소)를 저장"** <br>
→ 즉, "포인터처럼 작동"하는 부분이 있다

- 단, **메모리 주소를 직접 바꾼다거나, 포인터 산술, 역참조 등은 불가**