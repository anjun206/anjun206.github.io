# 소켓쌍

소켓이 뭔지부터 알아야 한다

## 소켓

소켓은 커널이 제공하는 네트워크 통신 끝점(endpoint)을 의미한다

보통 TCP/UDP 등 전송계층 프로토콜 위에서 쓰인다

## 소켓쌍

그리고 소켓쌍이란 하나의 TCP연결을 식별하는 두 소켓을 의미한다<br>
→ 보통 (출발 *IP:출발 포트*, 도착 *IP:도착 포트*)<br>
= (local *IP:local port*, remote *IP:remote port*)

그리고 소켓쌍은 **4튜플(4-tuple)**이라고도 하는데<br>
**(src IP, src port, dst IP, dst port)** 로 4개 들어있어서 그렇다

여기다가 추가로 L4프로토콜을 넣어 UDP인지 TCP인지도 구분가능케 한다 **(5튜플)**<br>
(이럴 경우는 보통 네트워크 장비에 쓰인다 L4 프로토콜 전부 다루기에 충돌 없어야 하니)

<br>

### 리스닝 소켓(listening socket)

받을 준비하는 소켓으로 서버가 준비해둔 **수신 대기용** 소켓이다<br>
`(0.0.0.0:포트)`와 같이 와일드카드 표시해둔다<br>
특정 IP에 바인드하지않고 이 포트를 모든 로컬 IP에서 받겠다는 뜻이다

### 연결 소켓(connected/established socket)

실제 통신하는 소켓으로 클라이언트의 연결을 받아서 새로 생기는 소켓이다<br>
**로컬/원격 IP:포트**가 모두 모인 완전체 4튜플이다

`accept()`로 생성된다

<br>

## 흐름 요약

1. 서버:<br>
   `socket()` → `bind(local_ip, 80)` → `listen()` → **리스닝 소켓 준비 (원격=\*)**

2. 클라:<br>
   `connect(server_ip, 80)` 전송

3. 서버:<br>
   `accept()` 호출 시 **새 파일디스크립터**가 생성 → **연결 소켓** 생김

- 예: `local 198.51.100.7:80` ↔ `remote 203.0.113.10:53012` (4튜플 완성)

4. 이후 데이터 주고받기는 **연결 소켓 FD**로 진행.
   리스닝 소켓은 계속 남아서 다음 접속을 또 `accept()`함.

> 즉, **리스닝 소켓 1개**에 대해 **연결 소켓이 여러 개** 매달리는 구조.

<br>



## 한눈에 비교

| 구분         | 리스닝 소켓                   | 연결 소켓                             |
| ------------ | ---------------------------- | ------------------------------------ |
| 용도         | 접속 대기                     | 실제 통신                             |
| 원격 주소     | 없음(`*`)                    | 있음(클라 IP:포트)                     |
| 상태          | `LISTEN`                    | `ESTABLISHED`                         |
| FD(디스크립터) | 1개(보통 고정)               | 접속마다 새로 생성(여러 개)             |
| 식별 기준      | (로컬 IP:포트, 프로토콜) 정도 | **4튜플**(src IP, src port, dst IP, dst port) |

<br>


## 예시

* 리스닝: `(0.0.0.0:80, *)`  ← 모든 인터페이스의 80포트에서 대기
* 연결1: `(198.51.100.7:80, 203.0.113.10:53012)`
* 연결2: `(198.51.100.7:80, 203.0.113.11:49822)`
  같은 서버 포트 80이라도 **원격 IP/포트가 달라서** 동시에 구분 가능.

리스닝 하나에 연결 여러개 생길 수 있다는 뜻